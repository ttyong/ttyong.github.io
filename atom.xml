<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TianYong&#39;s Blog</title>
  
  <subtitle>比你优秀的人都努力，有什么理由不努力！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tianyong.fun/"/>
  <updated>2022-04-16T14:05:55.600Z</updated>
  <id>http://tianyong.fun/</id>
  
  <author>
    <name>TTYONG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python廖雪峰-函数式编程 装饰器</title>
    <link href="http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%A3%85%E9%A5%B0%E5%99%A8.html"/>
    <id>http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E8%A3%85%E9%A5%B0%E5%99%A8.html</id>
    <published>2022-04-16T13:11:52.000Z</published>
    <updated>2022-04-16T14:05:55.600Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p><a href="https://blog.csdn.net/duyun0/article/details/118087073" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p><a href="https://www.cnblogs.com/hls-code/p/15318801.html" target="_blank" rel="external nofollow noopener noreferrer">优质参考</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" target="_blank" rel="external nofollow noopener noreferrer">廖雪峰Python-装饰器</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装饰器是在不改变原函数的源码和调用方式的情况下，为原函数增加功能</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</span><br></pre></td></tr></table></figure><h2 id="被装饰函数带参数-初级"><a href="#被装饰函数带参数-初级" class="headerlink" title="被装饰函数带参数-初级"></a>被装饰函数带参数-初级</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(fun)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(fun.__name__)</span><br><span class="line">        <span class="keyword">return</span> fun(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello"</span>)</span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_goodbye</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"goodbye"</span>)</span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_parameter</span><span class="params">(para)</span>:</span></span><br><span class="line">    print(para)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="string">''' # 不写@...可以这么用</span></span><br><span class="line"><span class="string">    say_hello = debug(say_hello)</span></span><br><span class="line"><span class="string">    say_hello()</span></span><br><span class="line"><span class="string">    say_goodbye = debug(say_goodbye)</span></span><br><span class="line"><span class="string">    say_goodbye()</span></span><br><span class="line"><span class="string">    say_parameter = debug(say_parameter)</span></span><br><span class="line"><span class="string">    say_parameter('Jack')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">say_hello</span></span><br><span class="line"><span class="string">Hello</span></span><br><span class="line"><span class="string">say_goodbye</span></span><br><span class="line"><span class="string">goodbye</span></span><br><span class="line"><span class="string">say_parameter</span></span><br><span class="line"><span class="string">Jack'''</span></span><br><span class="line">    </span><br><span class="line">有@...直接使用被装饰函数</span><br></pre></td></tr></table></figure><h2 id="装饰器带参数-高级"><a href="#装饰器带参数-高级" class="headerlink" title="装饰器带参数-高级"></a>装饰器带参数-高级</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数的闭包:</span><br><span class="line"><span class="number">1</span>、在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用【即外函数的返回值是内函数的内存地址】。这样就构成了一个闭包。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。</span><br><span class="line"></span><br><span class="line">但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装饰器的接口约定:</span><br><span class="line">装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了__call__()方法，那么这个对象就是callable的。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=level,</span><br><span class="line">                func=func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"say &#123;&#125;!"</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment"># say = logging(level='INFO')(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(something)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"do &#123;&#125;..."</span>.format(something)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'hello'</span>)</span><br><span class="line">    do(<span class="string">"my work"</span>)</span><br><span class="line"></span><br><span class="line">[INFO]: enter function say()</span><br><span class="line">say hello!</span><br><span class="line">[DEBUG]: enter function do()</span><br><span class="line">do my work...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">execute now():</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">和两层嵌套的decorator相比，<span class="number">3</span>层嵌套的效果是这样的：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">'execute'</span>)(now)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的<span class="string">'now'</span>变成了<span class="string">'wrapper'</span>：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">'wrapper'</span></span><br><span class="line">因为返回的那个wrapper()函数名字就是<span class="string">'wrapper'</span>，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</span><br><span class="line"></span><br><span class="line">不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">或者针对带参数的decorator：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"><span class="keyword">import</span> functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。</span><br></pre></td></tr></table></figure><h2 id="基于类实现的装饰器"><a href="#基于类实现的装饰器" class="headerlink" title="基于类实现的装饰器"></a>基于类实现的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logging</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        self.level = level</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span>  <span class="comment"># 接受函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(</span><br><span class="line">            <span class="string">"[&#123;level&#125;]: enter function &#123;func&#125;()"</span>.format(</span><br><span class="line">                level=self.level,</span><br><span class="line">                func=func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(level='INFO')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(something)</span>:</span></span><br><span class="line">    print(</span><br><span class="line">    <span class="string">"say &#123;&#125;!"</span>.format(something))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    say(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">[INFO]: enter function say()</span><br><span class="line">say hello!</span><br></pre></td></tr></table></figure><h2 id="内置装饰器"><a href="#内置装饰器" class="headerlink" title="内置装饰器"></a>内置装饰器</h2><p><a href="https://www.cnblogs.com/hls-code/p/15318801.html" target="_blank" rel="external nofollow noopener noreferrer">优质参考</a></p><p><a href="https://blog.csdn.net/YiJie__ShuSheng/article/details/84933648" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Python" scheme="http://tianyong.fun/categories/Python/"/>
    
    
      <category term="python廖雪峰" scheme="http://tianyong.fun/tags/python%E5%BB%96%E9%9B%AA%E5%B3%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘与机器学习-第一章</title>
    <link href="http://tianyong.fun/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0.html"/>
    <id>http://tianyong.fun/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E7%AB%A0.html</id>
    <published>2022-04-13T09:30:59.000Z</published>
    <updated>2022-04-19T12:09:05.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="数据挖掘与机器学习-第一章-数据挖掘的概念"><a href="#数据挖掘与机器学习-第一章-数据挖掘的概念" class="headerlink" title="数据挖掘与机器学习-第一章 数据挖掘的概念"></a>数据挖掘与机器学习-第一章 数据挖掘的概念</h1><h2 id="数据挖掘的定义"><a href="#数据挖掘的定义" class="headerlink" title="数据挖掘的定义"></a>数据挖掘的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广义角度:发现数据中的有用信息，从而帮助决策</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">技术过程:数据挖掘是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中，提取隐含在其中的、人们事先不知道的、但又是潜在又用的信息和知识，寻找其规律的技术，结合统计学、机器学习和人工智能技术的综合过程</span><br></pre></td></tr></table></figure><h2 id="数据挖据的目的"><a href="#数据挖据的目的" class="headerlink" title="数据挖据的目的"></a>数据挖据的目的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">两大基本目标是预测和描述数据</span><br><span class="line">其中预测的计算机建模及实现过程通常被称为:监督学习</span><br><span class="line">监督学习（supervised learning):从标记的训练数据来推断一个功能的机器学习任务。</span><br><span class="line">描述的通常称为:无监督学习</span><br><span class="line">无监督学习(unsupervised learning):根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题。往更细分，数据挖掘的目标可以分为以下这些:</span><br><span class="line">预测包含:回归、分类、...</span><br><span class="line">描述包含:聚类、关联规则发现....</span><br></pre></td></tr></table></figure><h2 id="数据挖掘技术"><a href="#数据挖掘技术" class="headerlink" title="数据挖掘技术"></a>数据挖掘技术</h2><h3 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计学:是关于认识客观规律总体数量特征和数量关系的科学。它是通过搜索、整理、分析统计资料，认识客观现象数量规律性的方法论科学。</span><br></pre></td></tr></table></figure><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">机器学习的英文名称叫Machine Learning，简称ML，是计算机科学的一个重要分支。它研究的是如何让计算机像人类一样学习，并能从中获取新的知识。</span><br><span class="line"></span><br><span class="line">一般的方法是：设定一些算法，让计算机从大量的数据中通过复杂计算总结出一些相关的规律和逻辑，然后这些规律和逻辑来预测未知的数据</span><br></pre></td></tr></table></figure><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200848899.png" alt="image-20220419200848899" style="zoom: 80%;"><h4 id="机器学习种类"><a href="#机器学习种类" class="headerlink" title="机器学习种类"></a>机器学习种类</h4><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419195517817.png" alt="image-20220419195517817" style="zoom: 67%;"><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200656385.png" alt="image-20220419200656385" style="zoom:67%;"><h5 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h5><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419195853584.png" alt="image-20220419195853584" style="zoom:67%;"><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419195925953.png" alt="image-20220419195925953" style="zoom:67%;"><h5 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h5><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200036550.png" alt="image-20220419200036550" style="zoom:67%;"><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200056318.png" alt="image-20220419200056318" style="zoom:67%;"><h2 id="数据挖掘与机器学习的过程"><a href="#数据挖掘与机器学习的过程" class="headerlink" title="数据挖掘与机器学习的过程"></a>数据挖掘与机器学习的过程</h2><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200336571.png" alt="image-20220419200336571" style="zoom:67%;"><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419200359451.png" alt="image-20220419200359451" style="zoom:67%;"><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据挖掘与机器学习" scheme="http://tianyong.fun/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据挖掘与机器学习-第二章 Pandas</title>
    <link href="http://tianyong.fun/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0.html"/>
    <id>http://tianyong.fun/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E7%AB%A0.html</id>
    <published>2022-04-13T09:30:51.000Z</published>
    <updated>2022-04-19T16:24:37.360Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="数据挖掘与机器学习-第二章-Pandas"><a href="#数据挖掘与机器学习-第二章-Pandas" class="headerlink" title="数据挖掘与机器学习-第二章 Pandas"></a>数据挖掘与机器学习-第二章 Pandas</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计学是关于认识客观现象总体数量特征和总体数量关系的科学</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">统计学常用指标:</span><br><span class="line">平均数</span><br><span class="line">绝对数与相对数</span><br><span class="line">百分比</span><br><span class="line">频率</span><br><span class="line">同比与环比</span><br></pre></td></tr></table></figure><h2 id="Pandas快速入门"><a href="#Pandas快速入门" class="headerlink" title="Pandas快速入门"></a>Pandas快速入门</h2><p><a href="https://blog.csdn.net/OohMuYi/article/details/111259411" target="_blank" rel="external nofollow noopener noreferrer">优质参考连接</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官网链接：http:&#x2F;&#x2F;pandas.pydata.org&#x2F; </span><br><span class="line">简介：Pandas是python的一个数据分析包，最初由AQR Capital Management于2008年4月开发，并于2009年底开源出来，目前由专注于Python数据包开发的PyData开发team继续开发和维护，属于PyData项目的一部分。Pandas最初被作为金融数据分析工具而开发出来，因此，pandas为时间序列分析提供了很好的支持。</span><br></pre></td></tr></table></figure><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419202003501.png" alt="image-20220419202003501"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419202018510.png" alt="image-20220419202018510"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Series-一维"><a href="#Series-一维" class="headerlink" title="Series(一维)"></a>Series(一维)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成</span><br><span class="line">Series的字符串表现形式为：索引在左边，值在右边</span><br></pre></td></tr></table></figure><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;ser1 = pd.Series(range(<span class="number">4</span>))</span><br><span class="line">&gt;&gt;&gt;ser2 = pd.Series(range(<span class="number">4</span>),index = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>])</span><br><span class="line">&gt;&gt;&gt;sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line">&gt;&gt;&gt;ser3 = pd.Series(sdata)</span><br><span class="line"></span><br><span class="line">注：传递的data是一个dict字典类型对象，并且传递了index参数，那么对应的值将从字典中取出。否则，index的值将由字典对象里的key值进行构造</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419203403486.png" alt="image-20220419203403486"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Series的index和values</span><br><span class="line">&gt;&gt;&gt;ser3.index</span><br><span class="line">&gt;&gt;&gt;ser3.values</span><br><span class="line">&gt;&gt;&gt;ser2[[<span class="string">"a"</span>,<span class="string">"c"</span>]]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419203503573.png" alt="image-20220419203503573"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419203611446.png" alt="image-20220419203611446"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419203735729.png" alt="image-20220419203735729"></p><h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><h6 id="下标访问和切片"><a href="#下标访问和切片" class="headerlink" title="下标访问和切片"></a>下标访问和切片</h6><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419203949053.png" alt="image-20220419203949053"></p><h6 id><a href="#" class="headerlink" title></a><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419204021047.png" alt="image-20220419204021047"></h6><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><h6 id="Series间的计算"><a href="#Series间的计算" class="headerlink" title="Series间的计算"></a>Series间的计算</h6><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419204341693.png" alt="image-20220419204341693"></p><h6 id="Series函数的使用"><a href="#Series函数的使用" class="headerlink" title="Series函数的使用"></a>Series函数的使用</h6><p><a href="https://wenku.baidu.com/view/5ba8fe5aa16925c52cc58bd63186bceb19e8ed6f.html" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p><strong>mean</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a &#x3D; pd.Series([1, 2, 3, 4, 5])</span><br><span class="line">平均值</span><br><span class="line">&gt;&gt;&gt;print(a.mean())</span><br><span class="line">&gt;&gt;&gt;3</span><br></pre></td></tr></table></figure><p><strong>isin</strong></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419205730838.png" alt="image-20220419205730838"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419210245276.png" alt="image-20220419210245276"></p><p><strong>unique和value_counts</strong></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419210635004.png" alt="image-20220419210635004"></p><p><strong>sort_index和sort_values</strong></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419211323708.png" alt="image-20220419211323708"></p><p><strong>抽样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.sample(n&#x3D;None,frac&#x3D;None,replace&#x3D;False,weights&#x3D;None,random_state&#x3D;None,axis&#x3D;None)</span><br><span class="line"></span><br><span class="line">n:指定抽取的样本量</span><br><span class="line">frac:指定抽取样本比例</span><br><span class="line">replace:是否又放回，默认又放回</span><br><span class="line">weights:指定样本抽中的概率，默认等论抽样</span><br><span class="line">random_state:指定抽样的随机种子</span><br></pre></td></tr></table></figure><p><a href="https://www.icode9.com/content-1-639722.html" target="_blank" rel="external nofollow noopener noreferrer">优质参考链接</a></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419233328091.png" alt="image-20220419233328091"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220419233414653.png" alt="image-20220419233414653"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220420001304292.png" alt="image-20220420001304292"></p><h6 id="统计运算-describe、isnull函数"><a href="#统计运算-describe、isnull函数" class="headerlink" title="统计运算(describe、isnull函数)"></a>统计运算(describe、isnull函数)</h6><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220420002152905.png" alt="image-20220420002152905"></p><p><img src="https://gitee.com/ttyong/hexoBlog/raw/master/Images/image-20220420002259906.png" alt="image-20220420002259906"></p><h4 id="DataFrame-二维"><a href="#DataFrame-二维" class="headerlink" title="DataFrame(二维)"></a>DataFrame(二维)</h4><h4 id="Panel-三维"><a href="#Panel-三维" class="headerlink" title="Panel(三维)"></a>Panel(三维)</h4><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="数据挖掘与机器学习" scheme="http://tianyong.fun/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Pandas" scheme="http://tianyong.fun/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>python-Flask库</title>
    <link href="http://tianyong.fun/python-Flask%E5%BA%93.html"/>
    <id>http://tianyong.fun/python-Flask%E5%BA%93.html</id>
    <published>2022-04-09T03:23:52.000Z</published>
    <updated>2022-04-09T05:56:47.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="Flask库"><a href="#Flask库" class="headerlink" title="Flask库"></a>Flask库</h1><p><a href="https://www.jb51.net/article/236776.htm" target="_blank" rel="external nofollow noopener noreferrer">参考链接</a></p><p><a href="https://flask.palletsprojects.com/en/0.12.x/" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a></p><h2 id="安装flask"><a href="#安装flask" class="headerlink" title="安装flask"></a>安装flask</h2><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h2 id="路径变量"><a href="#路径变量" class="headerlink" title="路径变量"></a>路径变量</h2><h2 id="构造URL"><a href="#构造URL" class="headerlink" title="构造URL"></a>构造URL</h2><h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><h2 id="模板生成"><a href="#模板生成" class="headerlink" title="模板生成"></a>模板生成</h2><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Python" scheme="http://tianyong.fun/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>cmd命令积累</title>
    <link href="http://tianyong.fun/cmd%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF.html"/>
    <id>http://tianyong.fun/cmd%E5%91%BD%E4%BB%A4%E7%A7%AF%E7%B4%AF.html</id>
    <published>2022-03-19T01:49:18.000Z</published>
    <updated>2022-03-21T12:33:30.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="cmd命令积累"><a href="#cmd命令积累" class="headerlink" title="cmd命令积累"></a>cmd命令积累</h1><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md(mkdir) filename</span><br></pre></td></tr></table></figure><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type nul &gt; file</span><br></pre></td></tr></table></figure><h2 id="写内容到文件"><a href="#写内容到文件" class="headerlink" title="写内容到文件"></a>写内容到文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'xxx'</span><br></pre></td></tr></table></figure><h2 id="查看运行进程，杀掉进程"><a href="#查看运行进程，杀掉进程" class="headerlink" title="查看运行进程，杀掉进程"></a>查看运行进程，杀掉进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasklist</span><br><span class="line"></span><br><span class="line">taskkill /pid 7</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="cmd" scheme="http://tianyong.fun/categories/cmd/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第7章 面试与核心复盘</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC7%E7%AB%A0-%E9%9D%A2%E8%AF%95%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%A4%8D%E7%9B%98.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC7%E7%AB%A0-%E9%9D%A2%E8%AF%95%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%A4%8D%E7%9B%98.html</id>
    <published>2022-03-02T02:10:40.000Z</published>
    <updated>2022-03-02T02:12:34.395Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第6章 TOP N主播统计</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC6%E7%AB%A0-TOP-N%E4%B8%BB%E6%92%AD%E7%BB%9F%E8%AE%A1.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC6%E7%AB%A0-TOP-N%E4%B8%BB%E6%92%AD%E7%BB%9F%E8%AE%A1.html</id>
    <published>2022-03-02T02:10:19.000Z</published>
    <updated>2022-03-02T02:12:28.621Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第5章 RDD持久化</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC5%E7%AB%A0-RDD%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC5%E7%AB%A0-RDD%E6%8C%81%E4%B9%85%E5%8C%96.html</id>
    <published>2022-03-02T02:09:51.000Z</published>
    <updated>2022-03-02T02:12:23.875Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第4章 transformation与action实战</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC4%E7%AB%A0-transformation%E4%B8%8Eaction%E5%AE%9E%E6%88%98.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC4%E7%AB%A0-transformation%E4%B8%8Eaction%E5%AE%9E%E6%88%98.html</id>
    <published>2022-03-02T02:09:21.000Z</published>
    <updated>2022-03-02T02:11:33.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第3章 spark实战: 单词统计</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC3%E7%AB%A0-spark%E5%AE%9E%E6%88%98-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC3%E7%AB%A0-spark%E5%AE%9E%E6%88%98-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1.html</id>
    <published>2022-03-02T02:08:24.000Z</published>
    <updated>2022-03-03T09:30:51.813Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第十周-第3章-spark实战-单词统计"><a href="#第十周-第3章-spark实战-单词统计" class="headerlink" title="第十周 第3章 spark实战: 单词统计"></a>第十周 第3章 spark实战: 单词统计</h1><h2 id="WordCount程序"><a href="#WordCount程序" class="headerlink" title="WordCount程序"></a>WordCount程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先看来一个快速入门案例，单词计数</span><br><span class="line">这个需求就是类似于我们在学习MapReduce的时候写的案例</span><br><span class="line">需求这样的：读取文件中的所有内容，计算每个单词出现的次数</span><br><span class="line">这个需求就没什么好分析的了，咱们之前在学习MapReduce的已经分析过了，接下来就来看一下使用Spark需要如何实现</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：由于Spark支持Java、Scala这些语言，目前在企业中大部分公司都是使用Scala语言进行开发，个别公司会使用java进行开发，为了加深大家对Spark的理解，也满足java老程序员的需求，针对本课程中的案例，我们都会先基于Scala代码进行详细的讲解，然后再使用java代码重新实现一遍</span><br></pre></td></tr></table></figure><h2 id="Scala代码开发"><a href="#Scala代码开发" class="headerlink" title="Scala代码开发"></a>Scala代码开发</h2><h3 id="scala代码"><a href="#scala代码" class="headerlink" title="scala代码"></a>scala代码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.scala</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需求：单词计数</span></span><br><span class="line"><span class="comment">* Created by xuwei</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCountScala</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="comment">//第一步：创建SparkContext</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">conf.setAppName(<span class="string">"WordCountScala"</span>)<span class="comment">//设置任务名称</span></span><br><span class="line">.setMaster(<span class="string">"local"</span>)<span class="comment">//local表示在本地执行</span></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="comment">//第二步：加载数据</span></span><br><span class="line"><span class="keyword">val</span> linesRDD = sc.textFile(<span class="string">"D:\\hello.txt"</span>)</span><br><span class="line"><span class="comment">//第三步：对数据进行切割，把一行数据切分成一个一个的单词</span></span><br><span class="line"><span class="keyword">val</span> wordsRDD = linesRDD.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="comment">//第四步：迭代words,将每个word转化为(word,1)这种形式</span></span><br><span class="line"><span class="keyword">val</span> pairRDD = wordsRDD.map((_,<span class="number">1</span>))</span><br><span class="line"><span class="comment">//第五步：根据key(其实就是word)进行分组聚合统计</span></span><br><span class="line"><span class="keyword">val</span> wordCountRDD = pairRDD.reduceByKey(_ + _)</span><br><span class="line"><span class="comment">//第六步：将结果打印到控制台</span></span><br><span class="line">wordCountRDD.foreach(wordCount=&gt;println(wordCount._1+<span class="string">"--"</span>+wordCount._2))</span><br><span class="line"><span class="comment">//第七步：停止SparkContext</span></span><br><span class="line">sc.stop()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行代码，结果如下</span><br><span class="line">you--1</span><br><span class="line">hello--2</span><br><span class="line">me--1</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们再来总结一下代码中这几个RDD中的数据结构</span><br><span class="line">val linesRDD &#x3D; sc.textFile(&quot;D:\\hello.txt&quot;)</span><br><span class="line"></span><br><span class="line">linesRDD中的数据是这样的：</span><br><span class="line">hello you</span><br><span class="line">hello me</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val wordsRDD &#x3D; linesRDD.flatMap(_.split(&quot; &quot;))</span><br><span class="line"></span><br><span class="line">wordsRDD中的数据是这样的：</span><br><span class="line">hello</span><br><span class="line">you</span><br><span class="line">hello</span><br><span class="line">me</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val pairRDD &#x3D; wordsRDD.map((_,1))</span><br><span class="line"></span><br><span class="line">pairRDD 中的数据是这样的</span><br><span class="line">(hello,1)</span><br><span class="line">(you,1)</span><br><span class="line">(hello,1)</span><br><span class="line">(me,1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val wordCountRDD &#x3D; pairRDD.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">wordCountRDD 中的数据是这样的</span><br><span class="line">(hello,2)</span><br><span class="line">(you,1)</span><br><span class="line">(me,1)</span><br></pre></td></tr></table></figure><h3 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.java;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaPairRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaRDD;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.JavaSparkContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.*;</span><br><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需求：单词计数</span></span><br><span class="line"><span class="comment">* Created by xuwei</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountJava</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：创建SparkContext：</span></span><br><span class="line"><span class="comment">//注意，针对java代码需要获取JavaSparkContext</span></span><br><span class="line">SparkConf conf = <span class="keyword">new</span> SparkConf();</span><br><span class="line">conf.setAppName(<span class="string">"WordCountJava"</span>)</span><br><span class="line">.setMaster(<span class="string">"local"</span>);</span><br><span class="line">JavaSparkContext sc = <span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：加载数据</span></span><br><span class="line">JavaRDD&lt;String&gt; linesRDD = sc.textFile(<span class="string">"D:\\hello.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步：对数据进行切割，把一行数据切分成一个一个的单词</span></span><br><span class="line"><span class="comment">//注意：FlatMapFunction的泛型，第一个参数表示输入数据类型，第二个表示是输出数据类型</span></span><br><span class="line">JavaRDD&lt;String&gt; wordsRDD = linesRDD.flatMap(<span class="keyword">new</span>     FlatMapFunction&lt;String,String&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String line)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.asList(line.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步：迭代words,将每个word转化为(word,1)这种形式</span></span><br><span class="line"><span class="comment">//注意：PairFunction的泛型，第一个参数是输入数据类型</span></span><br><span class="line"><span class="comment">//第二个是输出tuple中的第一个参数类型，第三个是输出tuple中的第二个参数类型</span></span><br><span class="line"><span class="comment">//注意：如果后面需要使用到....ByKey，前面都需要使用mapToPair去处理</span></span><br><span class="line">JavaPairRDD&lt;String, Integer&gt; pairRDD = wordRDD.mapToPair(<span class="keyword">new</span> PairFunction&lt;String,String,Integer&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">call</span><span class="params">(String word)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第五步：根据key(其实就是word)进行分组聚合统计</span></span><br><span class="line">JavaPairRDD&lt;String, Integer&gt; wordCountRDD =       pairRDD.reduceByKey(<span class="keyword">new</span> Function2&lt;Integer,Integer,Integer&gt;()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer i1, Integer i2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i1 + i2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第六步：将结果打印到控制台</span></span><br><span class="line">wordCountRDD.foreach(<span class="keyword">new</span> VoidFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Tuple2&lt;String, Integer&gt; tup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(tup._1+<span class="string">"--"</span>+tup._2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第七步：停止sparkContext</span></span><br><span class="line">sc.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在编写一行JAVA语句时，有返回值的方法已经决定了返回对象的类型和泛型类型，我们只需要给这个对象起个名字就行。</span><br><span class="line"></span><br><span class="line">如果使用快捷键生成这个返回值，我们就可以减少不必要的打字和思考，专注于过程的实现。</span><br><span class="line"></span><br><span class="line">1.把光标移动到需要生成返回值变量的语句之前</span><br><span class="line">2.右键Refactor-Extract-Variable，也可以按快捷键ctrl+alt+v</span><br></pre></td></tr></table></figure><p><a href="https://jingyan.baidu.com/article/63acb44a15ae7f61fcc17e8f.html" target="_blank" rel="external nofollow noopener noreferrer">url</a></p><h2 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对任务的提交有这么几种形式</span><br></pre></td></tr></table></figure><h3 id="使用idea"><a href="#使用idea" class="headerlink" title="使用idea"></a>使用idea</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接在idea中执行，方便在本地环境调试代码</span><br><span class="line">咱们刚才使用的就是这种方式</span><br></pre></td></tr></table></figure><h3 id="使用spark-submit"><a href="#使用spark-submit" class="headerlink" title="使用spark-submit"></a>使用spark-submit</h3><h4 id="添加打包所用依赖"><a href="#添加打包所用依赖" class="headerlink" title="添加打包所用依赖"></a>添加打包所用依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用spark-submit提交到集群执行，实际工作中会使用这种方式</span><br><span class="line">那接下来我们需要把我们的代码提交到集群中去执行</span><br><span class="line">这个时候就需要对代码打包了</span><br><span class="line">首先在项目的pom文件中添加 build 配置，和 dependencies 标签平级</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- java编译插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;source&gt;1.8&lt;&#x2F;source&gt;</span><br><span class="line">                    &lt;target&gt;1.8&lt;&#x2F;target&gt;</span><br><span class="line">                    &lt;encoding&gt;UTF-8&lt;&#x2F;encoding&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;!-- scala编译插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;net.alchim31.maven&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;scala-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.1.6&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;scalaCompatVersion&gt;2.11&lt;&#x2F;scalaCompatVersion&gt;</span><br><span class="line">                    &lt;scalaVersion&gt;2.11.12&lt;&#x2F;scalaVersion&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;compile-scala&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;phase&gt;compile&lt;&#x2F;phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;add-source&lt;&#x2F;goal&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;test-compile-scala&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;phase&gt;test-compile&lt;&#x2F;phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;add-source&lt;&#x2F;goal&gt;</span><br><span class="line">                            &lt;goal&gt;testCompile&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;!-- 打包插件 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-assembly-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;descriptorRefs&gt;</span><br><span class="line">                        &lt;descriptorRef&gt;jar-with-dependencies&lt;&#x2F;descriptorRef&gt;</span><br><span class="line">                    &lt;&#x2F;descriptorRefs&gt;</span><br><span class="line">                    &lt;archive&gt;</span><br><span class="line">                        &lt;manifest&gt;</span><br><span class="line">                            &lt;mainClass&gt;&lt;&#x2F;mainClass&gt;</span><br><span class="line">                        &lt;&#x2F;manifest&gt;</span><br><span class="line">                    &lt;&#x2F;archive&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;make-assembly&lt;&#x2F;id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;single&lt;&#x2F;goal&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改代码中的输入文件路径信息，因为这个时候无法读取windows中的数据了，把代码修改成动态接收输入文件路径</span><br><span class="line">还需要将 setMaster(&quot;local&quot;) 注释掉，后面我们会在提交任务的时候动态指定master信息</span><br><span class="line">修改WordCountScala</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建SparkContext</span></span><br><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">conf.setAppName(<span class="string">"WordCountScala"</span>)<span class="comment">//设置任务名称</span></span><br><span class="line"><span class="comment">//.setMaster("local")//local表示在本地执行</span></span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf);</span><br><span class="line"><span class="comment">//第二步：加载数据</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="string">"D:\\hello.txt"</span></span><br><span class="line"><span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">path = args(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> linesRDD = sc.textFile(path</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">修改<span class="type">WordCountJava</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：创建SparkContext：</span></span><br><span class="line"><span class="comment">//注意，针对java代码需要获取JavaSparkContext</span></span><br><span class="line"><span class="type">SparkConf</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>();</span><br><span class="line">conf.setAppName(<span class="string">"WordCountJava"</span>);</span><br><span class="line"><span class="comment">//.setMaster("local");</span></span><br><span class="line"><span class="type">JavaSparkContext</span> sc = <span class="keyword">new</span> <span class="type">JavaSparkContext</span>(conf);</span><br><span class="line"><span class="comment">//第二步：加载数据</span></span><br><span class="line"><span class="type">String</span> path = <span class="string">"D:\\hello.txt"</span>;</span><br><span class="line"><span class="keyword">if</span>(args.length==<span class="number">1</span>)&#123;</span><br><span class="line">path = args[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">JavaRDD</span>&lt;<span class="type">String</span>&gt; linesRDD = sc.textFile(path);</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure><h4 id="上传，提交任务"><a href="#上传，提交任务" class="headerlink" title="上传，提交任务"></a>上传，提交任务</h4><p><a href="https://spark.apache.org/docs/2.4.3" target="_blank" rel="external nofollow noopener noreferrer">2.4.3官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 提交任务格式</span><br><span class="line"># Run on a YARN cluster</span><br><span class="line">export HADOOP_CONF_DIR&#x3D;XXX</span><br><span class="line">.&#x2F;bin&#x2F;spark-submit \</span><br><span class="line">  --class org.apache.spark.examples.SparkPi \</span><br><span class="line">  --master yarn \</span><br><span class="line">  --deploy-mode cluster \  # can be client for client mode</span><br><span class="line">  --executor-memory 20G \</span><br><span class="line">  --num-executors 50 \</span><br><span class="line">  &#x2F;path&#x2F;to&#x2F;examples.jar \</span><br><span class="line">  1000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于spark-submit命令后面的参数有点多，所以在这我们最好是写一个脚本去提交任务</span><br><span class="line">[root@bigdata04 sparkjars]# vi wordCountJob.sh</span><br><span class="line">spark-submit \</span><br><span class="line">--class com.imooc.scala.WordCountScala \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode client \</span><br><span class="line">--executor-memory 1G \</span><br><span class="line">--num-executors 1 \</span><br><span class="line">db_spark-1.0-SNAPSHOT-jar-with-dependencies.jar \</span><br><span class="line">hdfs:&#x2F;&#x2F;bigdata01:9000&#x2F;test&#x2F;hello.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在提交任务之前还需要先把hadoop集群启动了，以及对应的historyserver进程(除了客户端节点，所有集群节点都需要启动)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@bigdata04 sparkjars]# sh -x wordCountJob.sh</span><br><span class="line"></span><br><span class="line">此时任务会被提交到YARN集群中，可以看到任务执行成功了(8088)</span><br><span class="line"></span><br><span class="line">但是注意：此时想要查看foreach中打印的结果目前是看不到的，需要通过spark自己的任务界面才能看到，现在只有在任务运行中的时候，我们才能进到spark的任务界面，任务执行结束之后我们就进不去了，一会我们再解决这个问题</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这就是第二种方式，使用spark-submit的方式提交任务到集群中执行</span><br><span class="line">其实spark-submit中还可以配置很多参数，具体等后面我们用到的时候再去详细分析，现在分析不太好</span><br><span class="line">理解</span><br></pre></td></tr></table></figure><h3 id="使用spark-shell"><a href="#使用spark-shell" class="headerlink" title="使用spark-shell"></a>使用spark-shell</h3><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第2章 解读spark工作与架构原理</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC2%E7%AB%A0-%E8%A7%A3%E8%AF%BBspark%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC2%E7%AB%A0-%E8%A7%A3%E8%AF%BBspark%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html</id>
    <published>2022-03-02T02:07:55.000Z</published>
    <updated>2022-03-02T07:02:39.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第十周-第2章-解读spark工作与架构原理"><a href="#第十周-第2章-解读spark工作与架构原理" class="headerlink" title="第十周 第2章 解读spark工作与架构原理"></a>第十周 第2章 解读spark工作与架构原理</h1><h2 id="Spark的工作原理"><a href="#Spark的工作原理" class="headerlink" title="Spark的工作原理"></a>Spark的工作原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面我们来分析一下Spark的工作原理</span><br><span class="line">来看这个图</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/b8Fban" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/03/02/b8Fban.md.png" alt="b8Fban.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  首先看中间是一个Spark集群，可以理解为是Spark的 standalone集群，集群中有6个节点</span><br><span class="line">  左边是Spark的客户端节点，这个节点主要负责向Spark集群提交任务，假设在这里我们向Spark集群提交了一个任务</span><br><span class="line">  那这个Spark任务肯定会有一个数据源，数据源在这我们使用HDFS，就是让Spark计算HDFS中的数据。</span><br><span class="line">  当Spark任务把HDFS中的数据读取出来之后，它会把HDFS中的数据转化为RDD，RDD其实是一个弹性分布式数据集，它其实是一个逻辑概念，在这你先把它理解为是一个数据集合就可以了，后面我们会详细分析这个RDD。</span><br><span class="line">  在这里这个RDD你就可以认为是包含了我们读取的HDFS上的数据</span><br><span class="line">其中这个RDD是有分区这个特性的，也就是一整份数据会被分成多份，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 假设我们现在从HDFS中读取的这份数据被转化为RDD之后，在RDD中分成了3份，那这3份数据可能会分布在3个不同的节点上面，对应这里面的节点1、节点2、节点3</span><br><span class="line">这个RDD的3个分区的数据对应的是partiton-1、partition-2、partition-3</span><br><span class="line">这样的好处是可以并行处理了，后期每个节点就可以计算当前节点上的这一个分区的数据。</span><br><span class="line"></span><br><span class="line">这个计算思想是不是类似于MapReduce里面的计算思想啊，本地计算，但是有一点区别就是这个RDD的数据是在内存中的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设现在这个RDD中每个分区中的数据有10w条</span><br><span class="line">  那接下来我们就想对这个RDD中的数据进行计算了，可以使用一些高阶函数进行计算，例如：flatMap、map之类的</span><br><span class="line">  那在这我们先使用flatMap对数据进行处理，把每一行数据转成多行数据</span><br><span class="line">此时flatMap这个函数就会在节点1、节点2和节点3上并行执行了。</span><br><span class="line">计算之后的结果还是一个带有分区的RDD，那这个RDD我们假设存在节点4、节点5和节点6上面。</span><br><span class="line"></span><br><span class="line">  此时每个节点上面会有一个分区的数据，我们给这些分区数据起名叫partition-4、partition-5、partition-6</span><br><span class="line">  正常情况下，前面节点1上的数据处理之后会发送到节点4上面</span><br><span class="line">另外两个节点也是一样的。</span><br><span class="line">  此时经过flatmap计算之后，前面RDD的数据传输到后面节点上面这个过程是不需要经过shuffle的，可以直接在内存中通过网络传输过去，因为现在这两个RDD的分区数量是一一对应的。</span><br></pre></td></tr></table></figure><h3 id="什么是RDD"><a href="#什么是RDD" class="headerlink" title="什么是RDD"></a>什么是RDD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RDD通常通过Hadoop上的文件，即HDFS文件进行创建，也可以通过程序中的集合来创建</span><br><span class="line">RDD是Spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集</span><br><span class="line">那我们接下来来看一下这个弹性分布式数据集的特点</span><br></pre></td></tr></table></figure><h4 id="RDD的特点"><a href="#RDD的特点" class="headerlink" title="RDD的特点"></a>RDD的特点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">弹性：RDD数据默认情况下存放在内存中，但是在内存资源不足时，Spark也会自动将RDD数据写入磁盘</span><br><span class="line">分布式：RDD在抽象上来说是一种元素数据的集合，它是被分区的，每个分区分布在集群中的不同节点上，从而让RDD中的数据可以被并行操作</span><br><span class="line">容错性：RDD最重要的特性就是提供了容错性，可以自动从节点失败中恢复过</span><br><span class="line"></span><br><span class="line">如果某个节点上的RDD partition，因为节点故障，导致数据丢了，那么RDD会自动通过自己的数据来源</span><br><span class="line">重新计算该partition的数据</span><br></pre></td></tr></table></figure><h2 id="Spark架构相关进程"><a href="#Spark架构相关进程" class="headerlink" title="Spark架构相关进程"></a>Spark架构相关进程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面我们来看一下Spark架构相关的进程信息</span><br><span class="line">注意：在这里是以Spark的standalone集群为例进行分析</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Driver：</span><br><span class="line">我们编写的Spark程序就在Driver(进程)上，由Driver进程负责执行</span><br><span class="line">Driver进程所在的节点可以是Spark集群的某一个节点或者就是我们提交Spark程序的客户端节点</span><br><span class="line">具体Driver进程在哪个节点上启动是由我们提交任务时指定的参数决定的，这个后面我们会详细分析</span><br><span class="line"></span><br><span class="line">Master：</span><br><span class="line">集群的主节点中启动的进程</span><br><span class="line">主要负责集群资源的管理和分配，还有集群的监控等</span><br><span class="line"></span><br><span class="line">Worker：</span><br><span class="line">集群的从节点中启动的进程</span><br><span class="line">主要负责启动其它进程来执行具体数据的处理和计算任务</span><br><span class="line"></span><br><span class="line">Executor：</span><br><span class="line">此进程由Worker负责启动，主要为了执行数据处理和计算</span><br><span class="line"></span><br><span class="line">Task：</span><br><span class="line">是一个线程</span><br><span class="line">由Executor负责启动，它是真正干活的</span><br></pre></td></tr></table></figure><h2 id="Spark架构原理"><a href="#Spark架构原理" class="headerlink" title="Spark架构原理"></a>Spark架构原理</h2><p><a href="https://imgtu.com/i/b8V1iR" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/03/02/b8V1iR.md.png" alt="b8V1iR.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面来看一个图，通过刚才那几个进程，我们来分析一下Spark的架构原理</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 首先我们在spark的客户端机器上通过driver进程执行我们的Spark代码</span><br><span class="line">当我们通过spark-submit脚本提交Spark任务的时候Driver进程就启动了。</span><br><span class="line">2. Driver进程启动之后，会做一些初始化的操作，会找到集群master进程，对Spark应用程序进行注册</span><br><span class="line">3. 当Master收到Spark程序的注册申请之后，会发送请求给Worker，进行资源的调度和分配</span><br><span class="line">4. Worker收到Master的请求之后，会为Spark应用启动Executor进程</span><br><span class="line">会启动一个或者多个Executor，具体启动多少个，会根据你的配置来启动</span><br><span class="line">5. Executor启动之后，会向Driver进行反注册，这样Driver就知道哪些Executor在为它服务了</span><br><span class="line">6. Driver会根据我们对RDD定义的操作，提交一堆的task去Executor上执行</span><br><span class="line">task里面执行的其实就是具体的map、flatMap这些操作。</span><br><span class="line"></span><br><span class="line">这就是Spark架构的原理</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第十周 第1章 初识spark</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86spark.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%8D%81%E5%91%A8-%E7%AC%AC1%E7%AB%A0-%E5%88%9D%E8%AF%86spark.html</id>
    <published>2022-03-02T02:07:23.000Z</published>
    <updated>2022-03-02T03:32:06.106Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第十周-第1章-初识spark"><a href="#第十周-第1章-初识spark" class="headerlink" title="第十周 第1章 初识spark"></a>第十周 第1章 初识spark</h1><h2 id="快速了解Spark"><a href="#快速了解Spark" class="headerlink" title="快速了解Spark"></a>快速了解Spark</h2><h3 id="什么是Spark"><a href="#什么是Spark" class="headerlink" title="什么是Spark"></a>什么是Spark</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spark是一个用于大规模数据处理的统一计算引擎</span><br><span class="line">注意：Spark不仅仅可以做类似于MapReduce的离线数据计算，还可以做实时数据计算，并且它还可以实现类似于Hive的SQL计算，等等，所以说它是一个统一的计算引擎</span><br><span class="line">既然说到了Spark，那就不得不提一下Spark里面最重要的一个特性：内存计算</span><br><span class="line">Spark中一个最重要的特性就是基于内存进行计算，从而让它的计算速度可以达到MapReduce的几十倍甚至上百倍</span><br><span class="line">所以说在这大家要知道，Spark是一个基于内存的计算引擎</span><br></pre></td></tr></table></figure><h3 id="Spark的特点"><a href="#Spark的特点" class="headerlink" title="Spark的特点"></a>Spark的特点</h3><h4 id="Speed：速度快"><a href="#Speed：速度快" class="headerlink" title="Speed：速度快"></a>Speed：速度快</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于Spark是基于内存进行计算的，所以它的计算性能理论上可以比MapReduce快100倍</span><br><span class="line">Spark使用最先进的DAG调度器、查询优化器和物理执行引擎，实现了高性能的批处理和流处理。</span><br><span class="line">注意：批处理其实就是离线计算，流处理就是实时计算，只是说法不一样罢了，意思是一样的</span><br></pre></td></tr></table></figure><h4 id="Easy-of-Use：易用性"><a href="#Easy-of-Use：易用性" class="headerlink" title="Easy of Use：易用性"></a>Easy of Use：易用性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Spark的易用性主要体现在两个方面</span><br><span class="line">1. 可以使用多种编程语言快速编写应用程序，例如Java、Scala、Python、R和SQL</span><br><span class="line">2. Spark提供了80多个高阶函数，可以轻松构建Spark任务。</span><br><span class="line">看这个图中的代码，spark可以直接读取json文件，使用where进行过滤，然后使用select查询指定字段中的值</span><br></pre></td></tr></table></figure><h4 id="Generality：通用性"><a href="#Generality：通用性" class="headerlink" title="Generality：通用性"></a>Generality：通用性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spark提供了Core、SQL、Streaming、MLlib、GraphX等技术组件，可以一站式地完成大数据领域的离线批处理、SQL交互式查询、流式实时计算，机器学习、图计算等常见的任务</span><br><span class="line">从这可以看出来Spark也是一个具备完整生态圈的技术框架，它不是一个人在战斗。</span><br></pre></td></tr></table></figure><h4 id="Runs-Everywhere：到处运行"><a href="#Runs-Everywhere：到处运行" class="headerlink" title="Runs Everywhere：到处运行"></a>Runs Everywhere：到处运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你可以在Hadoop YARN、Mesos或Kubernetes上使用Spark集群。</span><br><span class="line">并且可以访问HDFS、Alluxio、Apache Cassandra、Apache HBase、Apache Hive和数百个其它数据源中的数据</span><br></pre></td></tr></table></figure><h3 id="Spark-vs-Hadoop"><a href="#Spark-vs-Hadoop" class="headerlink" title="Spark vs Hadoop"></a>Spark vs Hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">那接下来我们拿Spark和Hadoop做一个对比</span><br><span class="line">在这里我们通过三个层面进行对比分析</span><br><span class="line">1. 综合能力</span><br><span class="line">Spark是一个综合性质的计算引擎</span><br><span class="line">Hadoop既包含MapReduce(计算引擎)，还包含HDFS(分布式存储)和Yarn(资源管理)</span><br><span class="line">所以说他们两个的定位是不一样的。</span><br><span class="line">从综合能力上来说，hadoop是完胜spark的</span><br><span class="line">2. 计算模型</span><br><span class="line">Spark 任务可以包含多个计算操作，轻松实现复杂迭代计算</span><br><span class="line">而Hadoop中的MapReduce任务只包含Map和Reduce阶段，不够灵活</span><br><span class="line">从计算模型上来说，spark是完胜hadoop的</span><br><span class="line">3. 处理速度</span><br><span class="line">Spark 任务的数据是基于内存的，计算速度很快</span><br><span class="line">而Hadoop中MapReduce 任务是基于磁盘的，速度较慢</span><br><span class="line">从处理速度上来说，spark也是完胜hadoop的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">之前有一种说法，说Spark将会替代Hadoop，这个说法是错误的，其实它们两个的定位是不一样的，Spark是一个通用的计算引擎，而Hadoop是一个包含HDFS、MapRedcue和YARN的框架，所以说Spark</span><br><span class="line">就算替代也只是替代Hadoop中的MapReduce，也不会整个替代Hadoop，因为Spark还需要依赖于Hadoop中的HDFS和YARN。</span><br><span class="line">所以在实际工作中Hadoop会作为一个提供分布式存储和分布式资源管理的角色存在Spark会在它之上去执行。</span><br><span class="line"></span><br><span class="line">所以在工作中就会把spark和hadoop结合到一块来使用</span><br></pre></td></tr></table></figure><h3 id="Spark-Hadoop"><a href="#Spark-Hadoop" class="headerlink" title="Spark+Hadoop"></a>Spark+Hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那下面我们来看一下Spark和Hadoop是如何结合</span><br><span class="line">看这个图</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/b3lMHf" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/03/02/b3lMHf.png" alt="b3lMHf.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">底层是Hadoop的HDFS和YARN</span><br><span class="line">Spark core指的是Spark的离线批处理</span><br><span class="line">Spark Streaming指的是Spark的实时流计算</span><br><span class="line">SparkSQL指的是Spark中的SQL计算</span><br><span class="line">Spark Mlib指的是Spark中的机器学习库，这里面集成了很多机器学习算法</span><br><span class="line">最后这个Spark GraphX是指图计算</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">其实这里面这么多模块，针对大数据开发岗位主要需要掌握的是Spark core、streaming、sql这几个模块，其中Mlib主要是搞算法的岗位使用的，GraphX这个要看是否有图计算相关的需求，所以这两个不是</span><br><span class="line">必须要掌握的。</span><br><span class="line">所以在本套体系课程中我们会学习Spark core、Spark SQL、还有Spark streaming这三块内容</span><br><span class="line">不过由于现在我们主要是学习离线批处理相关的内容，所以会先学习Spark core和Spark SQL，而Spark streaming等到后面我们讲到实时计算的时候再去学习。</span><br><span class="line"></span><br><span class="line">1.5：Spark的应用场景</span><br><span class="line">Spark主要应用在以下这些应用场景中</span><br><span class="line">1. 低延时的海量数据计算需求，这个说的就是针对Spark core的应用</span><br><span class="line">2. 低延时SQL交互查询需求，这个说的就是针对Spark SQL的应用</span><br><span class="line">3. 准实时(秒级)海量数据计算需求，这个说的就是Spark Streaming的应用</span><br></pre></td></tr></table></figure><h2 id="Spark集群安装部署"><a href="#Spark集群安装部署" class="headerlink" title="Spark集群安装部署"></a>Spark集群安装部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面我们对Spark有一个整体概念之后，下面我们来安装部署一下Spark，spark也是支持集群模式的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Spark集群有多种部署方式，比较常见的有Standalone模式和ON YARN模式</span><br><span class="line">Standalone模式就是说部署一套独立的Spark集群，后期开发的Spark任务就在这个独立的Spark集群中执行ON YARN模式是说使用现有的Hadoop集群，后期开发的Spark任务会在这个Hadoop集群中执行，此时这个Hadoop集群就是一个公共的了，不仅可以运行MapReduce任务，还可以运行Spark任务，这样集群的资源就可以共享了，并且也不需要再维护一套集群了，减少了运维成本和运维压力，一举两得。</span><br><span class="line">所以在实际工作中都会使用Spark ON YARN模式</span><br><span class="line">不过为了考虑到大家可能会有一些特殊场景确实要使用standalone模式部署独立的spark集群，所以在这，针对这两种部署模式我们都讲一下。</span><br><span class="line">那在具体安装部署之前，需要先下载Spark的安装包。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在这需要注意选择合适的安装包</span><br><span class="line">因为我们使用Spark的时候一般都是需要和Hadoop交互的，所以需要下载带有Hadoop依赖的安装包</span><br><span class="line">这个时候就需要选择Hadoop版本对应的Spark安装包，我们的Hadoop是3.2的，里面Hadoop的版本只有2.6和2.7的，那就退而求其次选择hadoop2.7对应的这个Spark安装包，其实也是没什么问题的，如果有强迫症的话，就需要下载Spark的源码包，自己编译配套版本的安装包了。</span><br><span class="line">其实在Spark3.0的那个预览版本里面是有和Hadoop3.2配套的版本的，不过那个不是稳定版本，不建议</span><br><span class="line">在生产环境下使用，所以就不考虑了</span><br></pre></td></tr></table></figure><h3 id="stand-alone"><a href="#stand-alone" class="headerlink" title="stand alone"></a>stand alone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于Spark集群也是支持主从的，在这我们使用三台机器，部署一套一主两从的集群</span><br><span class="line">主节点： bigdata01</span><br><span class="line">从节点： bigdata02,bigdata03</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：需要确保这几台机器上的基础环境是OK的，防火墙、免密码登录、还有JDK</span><br><span class="line">因为这几台机器我们之前已经使用过了，基础环境都是配置过的，所以说在这就直接使用了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">先在bigdata01上进行配置</span><br><span class="line">1.解压</span><br><span class="line">2.重名名spark-env.sh.template</span><br><span class="line">3.配置spark-env.sh</span><br><span class="line">在文件末尾增加这两行内容，指定JAVA_HOME和主节点的主机名</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;data&#x2F;soft&#x2F;jdk1.8</span><br><span class="line">export SPARK_MASTER_HOST&#x3D;bigdata01</span><br><span class="line"></span><br><span class="line">4.重命名slaves.template</span><br><span class="line">5.修改slaves</span><br><span class="line">将文件末尾的localhost去掉，增加bigdata02和bigdata03这两个从节点的主机名</span><br><span class="line">bigdata02</span><br><span class="line">bigdata03</span><br><span class="line"></span><br><span class="line">6.将修改好配置的spark安装包，拷贝到bigdata02和bigdata03上</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">启动Spark集群</span><br><span class="line">[root@bigdata01 soft]# cd spark-2.4.3-bin-hadoop2.7</span><br><span class="line">[root@bigdata01 spark-2.4.3-bin-hadoop2.7]# sbin&#x2F;start-all.sh</span><br><span class="line"></span><br><span class="line">验证</span><br><span class="line">[root@bigdata01 spark-2.4.3-bin-hadoop2.7]# jps</span><br><span class="line">1731 Master</span><br><span class="line"></span><br><span class="line">[root@bigdata02 ~]# jps</span><br><span class="line">1714 Worker</span><br><span class="line">[root@bigdata03 ~]# jps</span><br><span class="line">1707 Worker</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">还可以访问主节点的8080端口来查看集群信息</span><br><span class="line">http:&#x2F;&#x2F;bigdata01:8080&#x2F;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10. 提交任务</span><br><span class="line">那我们尝试向这个Spark独立集群提交一个spark任务</span><br><span class="line">提交任务的命令该如何写呢？</span><br><span class="line">来看一下Spark的官方文档</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要使用bin目录下的spark-submit脚本提交任务</span><br><span class="line">--class 指定需要指定的入口类</span><br><span class="line">--master指定集群的地址</span><br><span class="line">接着指定需要提交的任务jar包</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">停止Spark集群</span><br><span class="line">在主节点 bigdata01上执行</span><br><span class="line">[root@bigdata01 spark-2.4.3-bin-hadoop2.7]# sbin&#x2F;stop-all.sh</span><br></pre></td></tr></table></figure><h3 id="ON-YARN"><a href="#ON-YARN" class="headerlink" title="ON YARN"></a>ON YARN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ON YARN模式很简单，先保证有一个Hadoop集群，然后只需要部署一个Spark的客户端节点即可，不需要启动任何进程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意：Spark的客户端节点同时也需要是Hadoop的客户端节点，因为Spark需要依赖于Hadoop</span><br><span class="line">我们的Hadoop集群是 bigdata01、bigdata02、bigdata03</span><br><span class="line">那我们可以选择把Spark部署在一个单独的节点上就可以了，其实就类似于我们之前部署Hadoop的客户端节点。</span><br><span class="line">在这我们使用bigdata04来部署spark on yarn，因为这个节点同时也是Hadoop的客户端节点</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 将spark-2.4.3-bin-hadoop2.7.tgz上传到bigdata04的&#x2F;data&#x2F;soft目录中</span><br><span class="line">2. 解压</span><br><span class="line">3. 重命名spark-env.sh.template</span><br><span class="line">4. 修改 spark-env.sh</span><br><span class="line">在文件末尾增加这两行内容，指定JAVA_HOME和Hadoop的配置文件目录</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;data&#x2F;soft&#x2F;jdk1.8</span><br><span class="line">export HADOOP_CONF_DIR&#x3D;&#x2F;data&#x2F;soft&#x2F;hadoop-3.2.0&#x2F;etc&#x2F;hadoop</span><br><span class="line"></span><br><span class="line">5. 提交任务</span><br><span class="line">那我们通过这个spark客户点节点，向Hadoop集群上提交spark任务(具体提交方法，可到官网查看)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6. 可以到YARN的8088界面查看提交上去的任务信息</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://tianyong.fun/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第九周 第4章 Scala函数式编程</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC4%E7%AB%A0-Scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC4%E7%AB%A0-Scala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.html</id>
    <published>2022-03-01T01:35:01.000Z</published>
    <updated>2022-03-01T12:02:52.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第九周-第4章-Scala函数式编程"><a href="#第九周-第4章-Scala函数式编程" class="headerlink" title="第九周 第4章 Scala函数式编程"></a>第九周 第4章 Scala函数式编程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面我们来学习一下scala中最重要的内容，函数式编程，其实我们学习Scala这门语言就是因为它的这一个特性，咱们在最开始的时候给大家演示了，使用java代码实现函数式编程是很复杂的，而使用scala代码实现函数式编程就很轻松，很简单了。</span><br><span class="line">这块内容我们在后续工作中会经常使用，需要大家重点掌握。</span><br></pre></td></tr></table></figure><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scala是一门既面向对象，又面向过程的语言。</span><br><span class="line">因此在Scala中有非常好的面向对象的特性，可以使用Scala来基于面向对象的思想开发大型复杂的系统和工程；</span><br><span class="line">而且Scala也面向过程，因此Scala中有函数的概念。</span><br><span class="line">在Scala中，函数与类、对象一样，都是一等公民，所以说scala的面向过程其实就重在针对函数的编程了，所以称之为函数式编程</span><br></pre></td></tr></table></figure><h2 id="函数赋值给变量"><a href="#函数赋值给变量" class="headerlink" title="函数赋值给变量"></a>函数赋值给变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scala中的函数是一等公民，可以独立定义，独立存在，而且可以直接将函数作为值赋值给变量</span><br><span class="line">Scala的语法规定，将函数赋值给变量时，必须在函数后面加上空格和下划线</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>) &#123; println(<span class="string">"Hello, "</span> + name) &#125;</span><br><span class="line">sayHello: (name: <span class="type">String</span>)<span class="type">Unit</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> sayHelloFunc = sayHello _</span><br><span class="line">sayHelloFunc: <span class="type">String</span> =&gt; <span class="type">Unit</span> = &lt;function1&gt;</span><br><span class="line">scala&gt; sayHelloFunc(<span class="string">"scala"</span>)</span><br><span class="line"><span class="type">Hello</span>, scala</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scala中的函数也可以不需要命名，这种函数称为匿名函数</span><br><span class="line">匿名函数的语法格式：(参数名: 参数类型) &#x3D;&gt; 函数体</span><br><span class="line">(参数名: 参数类型) ：是函数的参数列表</span><br><span class="line"></span><br><span class="line">可以将匿名函数直接赋值给某个变量</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> sayHelloFunc = (name: <span class="type">String</span>) =&gt; println(<span class="string">"Hello, "</span> + name)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> sayHelloFunc = (name: <span class="type">String</span>) =&gt; &#123;println(<span class="string">"Hello, "</span> + name)&#125;</span><br><span class="line"></span><br><span class="line">注意：如果函数体有多行代码，则需要添加&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于函数是一等公民，所以说我们可以直接将某个函数作为参数传入其它函数</span><br><span class="line">这个功能是极其强大的，也是Java这种面向对象的编程语言所不具备的</span><br><span class="line">这个功能在实际工作中是经常需要用到的</span><br><span class="line">接收其它函数作为当前函数的参数，当前这个函数也被称作高阶函数 (higher-order function)</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">看一个例子：</span><br><span class="line">先定义一个匿名函数，赋值给变量sayHelloFunc</span><br><span class="line"><span class="keyword">val</span> sayHelloFunc = (name: <span class="type">String</span>) =&gt; println(<span class="string">"Hello, "</span> + name)</span><br><span class="line"></span><br><span class="line">再定义一个高阶函数，这个高阶函数的参数会接收一个函数</span><br><span class="line">参数： (<span class="type">String</span>) =&gt; <span class="type">Unit</span> 表示这个函数接收一个字符串，没有返回值</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span>(func: (<span class="type">String</span>) =&gt; <span class="type">Unit</span>, name: <span class="type">String</span>) &#123; func(name) &#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; greeting(sayHelloFunc, <span class="string">"scala"</span>)</span><br><span class="line"><span class="type">Hello</span>, scala</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">或者还可以这样用，直接把匿名函数的定义传过来也是可以</span><br><span class="line">scala&gt; greeting((name: <span class="type">String</span>) =&gt; println(<span class="string">"Hello, "</span> + name),<span class="string">"scala"</span>)</span><br><span class="line"><span class="type">Hello</span>, scala</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">高阶函数可以自动推断出它里面函数的参数类型，对于只有一个参数的函数，还可以省去小括号</span><br><span class="line"># 先定义一个高阶函数</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span>(func: (<span class="type">String</span>) =&gt; <span class="type">Unit</span>, name: <span class="type">String</span>) &#123; func(name) &#125;</span><br><span class="line"># 使用高阶函数：完整写法</span><br><span class="line">greeting((name: <span class="type">String</span>) =&gt; println(<span class="string">"Hello, "</span> + name), <span class="string">"scala"</span>)</span><br><span class="line"># 使用高阶函数：高阶函数可以自动推断出参数类型，而不需要写明类型</span><br><span class="line">greeting((name) =&gt; println(<span class="string">"Hello, "</span> + name), <span class="string">"scala"</span>)</span><br><span class="line"># 使用高阶函数：对于只有一个参数的函数，还可以省去其小括号</span><br><span class="line">greeting(name =&gt; println(<span class="string">"Hello, "</span> + name), <span class="string">"scala"</span>)</span><br></pre></td></tr></table></figure><h2 id="常用高阶函数"><a href="#常用高阶函数" class="headerlink" title="常用高阶函数"></a>常用高阶函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">刚才是我们自己实现的高阶函数，其实我们在工作中自己定义高阶函数的场景不多，大部分场景都是去使</span><br><span class="line">用已有的高阶函数</span><br><span class="line">下面我们来看几个常见的高阶函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map：对传入的每个元素都进行处理，返回一个元素</span><br><span class="line">flatMap：对传入的每个元素都进行处理，返回一个或者多个元素</span><br><span class="line">foreach：对传入的每个元素都进行处理，但是没有返回值</span><br><span class="line">filter：对传入的每个元素都进行条件判断，如果返回true，则保留该元素，否则过滤掉该元素</span><br><span class="line">reduceLeft：从左侧元素开始，进行reduce操作</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(num=&gt;&#123;num * <span class="number">2</span>&#125;)</span><br><span class="line">res38: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">可以简写为</span><br><span class="line">scala&gt; <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(_ * <span class="number">2</span>)</span><br><span class="line">res40: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Array</span>(<span class="string">"hello you"</span>,<span class="string">"hello me"</span>).flatMap(line=&gt;line.split(<span class="string">" "</span>))</span><br><span class="line">res53: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(hello, you, hello, me)</span><br><span class="line"></span><br><span class="line">可以简写为</span><br><span class="line">scala&gt; <span class="type">Array</span>(<span class="string">"hello you"</span>,<span class="string">"hello me"</span>).flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">res54: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(hello, you, hello, me)</span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(_ * <span class="number">2</span>).foreach(num=&gt;println(num))</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(_ * <span class="number">2</span>).foreach(println(_))</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).map(_ * <span class="number">2</span>).foreach(println _)</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; Array(1, 2, 3, 4, 5).filter(num&#x3D;&gt;num % 2 &#x3D;&#x3D; 0)</span><br><span class="line">res46: Array[Int] &#x3D; Array(2, 4)</span><br><span class="line"></span><br><span class="line">scala&gt; Array(1, 2, 3, 4, 5).filter(_ % 2 &#x3D;&#x3D; 0)</span><br><span class="line">res47: Array[Int] &#x3D; Array(2, 4)</span><br></pre></td></tr></table></figure><h3 id="reduceLeft"><a href="#reduceLeft" class="headerlink" title="reduceLeft"></a>reduceLeft</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">reduceLeft的使用</span><br><span class="line">表示先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推spark中有一个reduce函数，和这个函数的效果一致</span><br><span class="line"></span><br><span class="line">scala&gt; Array(1, 2, 3, 4, 5).reduceLeft((t1,t2)&#x3D;&gt;t1+t2)</span><br><span class="line">res50: Int &#x3D; 15</span><br><span class="line"></span><br><span class="line">scala&gt; Array(1, 2, 3, 4, 5).reduceLeft( _ + _)</span><br><span class="line">res49: Int &#x3D; 15</span><br><span class="line"></span><br><span class="line">注意：这里的两个_代表是两个元素</span><br></pre></td></tr></table></figure><h2 id="案例：函数式编程"><a href="#案例：函数式编程" class="headerlink" title="案例：函数式编程"></a>案例：函数式编程</h2> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">统计多个文本内的单词总数</span><br><span class="line">使用scala的io包读取文本文件内的数据</span><br><span class="line"></span><br><span class="line">使用<span class="type">List</span>的伴生对象，将多个文件内的内容创建为一个<span class="type">List</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines01 = scala.io.<span class="type">Source</span>.fromFile(<span class="string">"D://a.txt"</span>).mkString</span><br><span class="line"><span class="keyword">val</span> lines02 = scala.io.<span class="type">Source</span>.fromFile(<span class="string">"D://b.txt"</span>).mkString</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> lines = <span class="type">List</span>(lines01, lines02)</span><br><span class="line"></span><br><span class="line">注意：下面这一行是核心代码，使用了链式调用的函数式编程</span><br><span class="line">lines.flatMap(_.split( <span class="string">" "</span>)).map((_, <span class="number">1</span>)).map(_._2).reduceLeft(_ + _)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines.flatMap(_.split( <span class="string">" "</span>)) ：表示对每一行数据使用空格进行切割，返回每一个单词</span><br><span class="line">.map((_, <span class="number">1</span>)) ：针对每一个单词，都转成tuple类型，tuple中的第<span class="number">1</span>个元素是这个单词，第<span class="number">2</span>个元素表示单词出现的次数<span class="number">1</span></span><br><span class="line">.map(_._2) ：迭代每一个tuple，获取tuple中的第<span class="number">2</span>个元素</span><br><span class="line">.reduceLeft(_ + _) ：对前面获取到的元素进行累加求和</span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="http://tianyong.fun/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第九周 第5章 Scala高级特性</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC5%E7%AB%A0-Scala%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC5%E7%AB%A0-Scala%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html</id>
    <published>2022-03-01T01:35:01.000Z</published>
    <updated>2022-03-02T01:13:42.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第九周-第5章-Scala高级特性"><a href="#第九周-第5章-Scala高级特性" class="headerlink" title="第九周 第5章 Scala高级特性"></a>第九周 第5章 Scala高级特性</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先看一下模式匹配</span><br><span class="line">模式匹配是<span class="type">Scala</span>中非常有特色，非常强大的一种功能。</span><br><span class="line">模式匹配，其实类似于<span class="type">Java</span>中的 switch <span class="keyword">case</span> 语法，即对一个值进行条件判断，然后针对不同的条件，进</span><br><span class="line">行不同的处理</span><br><span class="line">不过<span class="type">Scala</span>没有<span class="type">Java</span>中的 switch <span class="keyword">case</span> 语法，但是，<span class="type">Scala</span>提供了更加强大的 <span class="keyword">match</span> <span class="keyword">case</span> 语法，就是这个</span><br><span class="line">模式匹配</span><br><span class="line"><span class="type">Java</span>的 switch <span class="keyword">case</span> 仅能匹配变量的值，而<span class="type">Scala</span>的 <span class="keyword">match</span> <span class="keyword">case</span> 可以匹配各种情况，比如：变量的类型、</span><br><span class="line">集合的元素，有值没值</span><br></pre></td></tr></table></figure><h3 id="对变量的值进行模式匹配"><a href="#对变量的值进行模式匹配" class="headerlink" title="对变量的值进行模式匹配"></a>对变量的值进行模式匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">match case语法格式：变量 match &#123; case 值 &#x3D;&gt; 代码 &#125;</span><br><span class="line">如果值为下划线，则代表了不满足以上所有情况下的默认处理</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span></span>(day: <span class="type">Int</span>) &#123;</span><br><span class="line">day <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">"Monday"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> =&gt; println(<span class="string">"Tuesday"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> =&gt; println(<span class="string">"Wednesday"</span>)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; println(<span class="string">"none"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; demo1(<span class="number">1</span>)</span><br><span class="line"><span class="type">Monday</span></span><br><span class="line">scala&gt; demo1(<span class="number">4</span>)</span><br><span class="line">none</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：match case中，只要一个case分支满足并处理了，就不会继续判断下一个case分支了，这一点与Java不同，java的switch case需要用break停止向下执行</span><br></pre></td></tr></table></figure><h3 id="变量类型的模式匹配"><a href="#变量类型的模式匹配" class="headerlink" title="变量类型的模式匹配"></a>变量类型的模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scala</span>的模式匹配一个强大之处就在于，可以直接匹配类型，而不是值！！！这点是java的switch <span class="keyword">case</span>绝对做不到的</span><br><span class="line">语法格式：变量 <span class="keyword">match</span> &#123; <span class="keyword">case</span> 变量: 类型 =&gt; 代码 &#125;</span><br><span class="line">典型的一个应用场景就是针对异常的处理</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processException</span></span>(e: <span class="type">Exception</span>) &#123;</span><br><span class="line">e <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e1: <span class="type">IllegalArgumentException</span> =&gt; println(<span class="string">"IllegalArgumentException "</span></span><br><span class="line"><span class="keyword">case</span> e2: <span class="type">FileNotFoundException</span> =&gt; println(<span class="string">"FileNotFoundException "</span> + e2)</span><br><span class="line"><span class="keyword">case</span> e3: <span class="type">IOException</span> =&gt; println(<span class="string">"IOException "</span> + e3)</span><br><span class="line"><span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; println(<span class="string">"Exception "</span> )</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; processException(<span class="keyword">new</span> <span class="type">Exception</span>())</span><br><span class="line"><span class="type">Exception</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在<span class="keyword">try</span>-<span class="keyword">catch</span>异常中的应用</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">val</span> lines02 = scala.io.<span class="type">Source</span>.fromFile(<span class="string">"D://test02.txt"</span>).mkString</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; println(<span class="string">"no file"</span>)</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; println(<span class="string">"io exception"</span>)</span><br><span class="line"><span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt; println(<span class="string">"exception"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="case-class与模式匹配"><a href="#case-class与模式匹配" class="headerlink" title="case class与模式匹配"></a>case class与模式匹配</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scala</span>中提供了一种特殊的类，用 <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">进行声明，中文可以称为样例类</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">其实有点类似于Java中的JavaBean的概念</span></span></span><br><span class="line"><span class="class"><span class="title">即只定义field，会由Scala在编译时自动提供get和set方法，但是没有其它的method</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰（但是如果你自己使用var修饰，那么还是会按照var来，在这用哪个区别都不大）</span></span></span><br><span class="line"><span class="class"><span class="title">Scala自动为</span> <span class="title">case</span> <span class="title">class</span> <span class="title">定义了伴生对象，也就是object，并且定义了apply</span>(<span class="params"></span>)<span class="title">方法，该方法接收主构造函数中相同的参数，并返回</span> <span class="title">case</span> <span class="title">class</span> <span class="title">对象</span></span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Teacher</span>(<span class="params">name: <span class="type">String</span>, sub: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Student</span>(<span class="params">name: <span class="type">String</span>, cla: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">check</span>(<span class="params">p: <span class="type">Person</span></span>) </span>&#123;</span><br><span class="line">p <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Teacher</span>(name, sub) =&gt; println(<span class="string">"Teacher, name is "</span> + name + <span class="string">", sub is "</span> + sub)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Student</span>(name, cla) =&gt; println(<span class="string">"Student, name is "</span> + name + <span class="string">", cla is "</span> + cla)</span><br><span class="line"><span class="keyword">case</span> _ =&gt; println(<span class="string">"none"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行</span><br><span class="line">scala&gt; check(<span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"tom"</span>,<span class="string">"class1"</span>))</span><br><span class="line"><span class="type">Student</span>, name is tom, cla is class1</span><br><span class="line">scala&gt; check(<span class="keyword">new</span> <span class="type">Person</span>())</span><br><span class="line">none</span><br></pre></td></tr></table></figure><h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scala有一种特殊的数据类型，叫做Option。</span><br><span class="line">Option有两种值，一种是Some，表示有值，一种是None，表示没有值</span><br><span class="line">Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值，这比null来的更加简洁明了</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/b1Mnh9" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/03/01/b1Mnh9.md.png" alt="b1Mnh9.md.png"></a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ages = <span class="type">Map</span>(<span class="string">"jack"</span> -&gt; <span class="number">18</span>, <span class="string">"tom"</span> -&gt; <span class="number">30</span>, <span class="string">"jessic"</span> -&gt; <span class="number">27</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAge</span></span>(name: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="keyword">val</span> age = ages.get(name)</span><br><span class="line">age <span class="keyword">match</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">Some</span>(age) =&gt; println(<span class="string">"your age is "</span> + age)</span><br><span class="line"><span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">"none"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; getAge(<span class="string">"jack"</span>)</span><br><span class="line">your age is <span class="number">18</span></span><br><span class="line">scala&gt; getAge(<span class="string">"hehe"</span>)</span><br><span class="line">none</span><br></pre></td></tr></table></figure><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scala的隐式转换，允许手动指定将某种类型的对象转换成其它类型的对象</span><br><span class="line">Scala的隐式转换，最核心的就是定义隐式转换函数，即implicit conversion function</span><br><span class="line">隐式转换函数与普通函数唯一的语法区别是要以implicit开头而且最好要定义函数返回类型</span><br><span class="line">隐式转换非常强大的一个功能，就是可以在不知不觉中加强现有类型的功能。也就是说，我们可以为某个普通类定义一个加强类，并定义对应的隐式转换函数，这样我们在使用加强类里面的方法的时候，Scala会自动进行隐式转换，把普通类转换为加强类，然后再调用加强类中的方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scala默认会自动使用两种隐式转换</span><br><span class="line">1：源类型，或者目标类型的伴生对象里面的隐式转换函数</span><br><span class="line">2：当前程序作用域内可以用唯一标识符表示的隐式转换函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果隐式转换函数不在上述两种情况下的话，那么就必须手动使用import引入对应的隐式转换函数</span><br><span class="line">通常建议，仅仅在需要进行隐式转换的地方，比如某个函数内，用import导入隐式转换函数，这样可以缩小隐式转换函数的作用域，避免不需要的隐式转换</span><br></pre></td></tr></table></figure><h2 id="案例：狗也能抓老鼠"><a href="#案例：狗也能抓老鼠" class="headerlink" title="案例：狗也能抓老鼠"></a>案例：狗也能抓老鼠</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">通过隐式转换实现，狗也具备猫抓老鼠的功能</span><br><span class="line"></span><br><span class="line">class cat(val name: String)&#123;</span><br><span class="line">def catchMouse()&#123;println(name+&quot; catch mouse&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class dog(val name: String)</span><br><span class="line"></span><br><span class="line">implicit def object2Cat (obj: Object): cat &#x3D; &#123;</span><br><span class="line">if (obj.getClass &#x3D;&#x3D; classOf[dog]) &#123;</span><br><span class="line">val dog &#x3D; obj.asInstanceOf[dog]</span><br><span class="line">new cat(dog.name)</span><br><span class="line">&#125;</span><br><span class="line">else Nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> d = <span class="keyword">new</span> dog(<span class="string">"d1"</span>)</span><br><span class="line">d: dog = dog@<span class="number">7</span>f0e0db3</span><br><span class="line">scala&gt; d.catchMouse()</span><br><span class="line">d1 <span class="keyword">catch</span> mouse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们后续在工作中一般很少需要我们自己去定义隐式转换函数，大部分的场景是我们只需要使用<span class="keyword">import</span></span><br><span class="line">导入对应的隐式转换函数就可以了，在这个案例中我们是自己手工实现了一个隐私转换函数，因为他们都在一个作用域内，所以就不需要<span class="keyword">import</span>了</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>主构造函数里的参数，要用<span class="keyword">var</span>或<span class="keyword">val</span>修饰；函数不用</span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="http://tianyong.fun/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第九周 第3章 Scala面向对象</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC3%E7%AB%A0-Scala%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC3%E7%AB%A0-Scala%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html</id>
    <published>2022-03-01T01:35:01.000Z</published>
    <updated>2022-03-01T06:56:15.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第九周-第3章-Scala面向对象"><a href="#第九周-第3章-Scala面向对象" class="headerlink" title="第九周 第3章 Scala面向对象"></a>第九周 第3章 Scala面向对象</h1><h2 id="Scala面向对象编程"><a href="#Scala面向对象编程" class="headerlink" title="Scala面向对象编程"></a>Scala面向对象编程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在这里我们主要学习Scala中的类、对象和接口</span><br><span class="line">注意：</span><br><span class="line">Scala中类和java中的类基本是类似的</span><br><span class="line">Scala中的对象时需要定义的，而java中的对象是通过class new出来的</span><br><span class="line">Scala中的接口是trait，java中的接口是interface</span><br></pre></td></tr></table></figure><h3 id="类-class"><a href="#类-class" class="headerlink" title="类-class"></a>类-class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先看一下类</span><br><span class="line">Scala中定义类和Java一样，都是使用 class 关键字</span><br><span class="line">和Java一样，使用new关键字创建对象</span><br><span class="line">那下面来看一个具体案例</span><br><span class="line">定义Person类，创建对象并调用其方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">var name &#x3D; &quot;scala&quot;</span><br><span class="line">def sayHello()&#123;</span><br><span class="line">println(&quot;Hello,&quot;+name)</span><br><span class="line">&#125;</span><br><span class="line">def getName&#x3D; name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：如果在定义方法的时候指定了()，那么在调用的时候()可写可不写，如果在定义方法的时候</span><br><span class="line">没指定()，则调用方法时肯定不能带()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val p &#x3D; new Person()</span><br><span class="line">p: Person &#x3D; Person@23b8d9f3</span><br><span class="line">scala&gt; p.sayHello()</span><br><span class="line">Hello,scala</span><br><span class="line">scala&gt; p.sayHello</span><br><span class="line">Hello,scala</span><br><span class="line">scala&gt; println(p.getName)</span><br><span class="line">scala</span><br><span class="line">scala&gt; println(p.getName())</span><br><span class="line">&lt;console&gt;:10: error: not enough arguments for method apply: (index: Int)Char</span><br></pre></td></tr></table></figure><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类创建好了，下面我们来看一下类中的构造函数，</span><br><span class="line">Scala类中的构造函数可以分为主构造函数和辅助构造函数</span><br><span class="line">这两种构造函数有什么区别呢？</span><br><span class="line">主constructor：类似Java的默认构造函数 this()</span><br><span class="line">辅助constructor：类似Java的重载构造函数 this(name,age)</span><br></pre></td></tr></table></figure><h5 id="主constructor"><a href="#主constructor" class="headerlink" title="主constructor"></a>主constructor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">那先来看一下主构造函数</span><br><span class="line">Scala的主constructor是与类名放在一起的，与Java不同，Java中的构造函数是写在类内部的</span><br><span class="line"></span><br><span class="line">注意：在类中，没有定义在任何方法或者是代码块之中的代码就是主constructor的代码</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name:<span class="type">String</span>,val age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">println(<span class="string">"your name is "</span> + name + <span class="string">", your age is "</span> + age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"zs"</span>,<span class="number">19</span>)</span><br><span class="line">your name is zs, your age is <span class="number">19</span></span><br><span class="line">res8: <span class="type">Student</span> = <span class="type">Student</span>@<span class="number">3134153</span>d</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在创建对象的时候，类中的println语句执行了，说明这个语句属于主构造函数中的代码</span><br><span class="line">主constructor中还可以通过使用默认参数，来给参数设置默认值</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">val name:<span class="type">String</span> = "jack",val age:<span class="type">Int</span> = 20</span>)</span>&#123;</span><br><span class="line">println(<span class="string">"your name is "</span> + name + <span class="string">", your age is "</span> + age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Student</span>()</span><br><span class="line">your name is jack, your age is <span class="number">20</span></span><br><span class="line">res10: <span class="type">Student</span> = <span class="type">Student</span>@<span class="number">7</span>ddd84b5</span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"tom"</span>,<span class="number">18</span>)</span><br><span class="line">your name is tom, your age is <span class="number">18</span></span><br><span class="line">res11: <span class="type">Student</span> = <span class="type">Student</span><span class="meta">@a</span>09303</span><br></pre></td></tr></table></figure><h5 id="辅构造函数"><a href="#辅构造函数" class="headerlink" title="辅构造函数"></a>辅构造函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scala中，可以给类定义多个辅助constructor，类似于java中的构造函数重载</span><br><span class="line">辅助constructor之间可以互相调用，但是第一行必须调用主constructor</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"jack"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>()</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>(name)</span><br><span class="line"><span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"tom"</span>)</span><br><span class="line">s: <span class="type">Student</span> = <span class="type">Student</span>@<span class="number">1</span>a538ed8</span><br><span class="line">scala&gt; <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"mick"</span>,<span class="number">30</span>)</span><br><span class="line">s: <span class="type">Student</span> = <span class="type">Student</span>@<span class="number">319642</span>db</span><br></pre></td></tr></table></figure><h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象-object"></a>对象-object</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">前面我们学习的scala中的<span class="class"><span class="keyword">class</span><span class="title">和java中的class是类似的，下面来看一个java中没有的内容，叫Object</span></span></span><br><span class="line"><span class="class"><span class="title">那大家可能有疑问了，Java中也有object，通过class就可以创建object</span></span></span><br><span class="line"><span class="class"><span class="title">但是注意了，在scala中，我们可以直接定义一个object，就像定义class一样。</span></span></span><br><span class="line"><span class="class"><span class="title">object：相当于class的单个实例，通常在里面放一些静态的field或者method</span></span></span><br><span class="line"><span class="class"><span class="title">object不能定义带参数的constructor，只有空参的constructor</span></span></span><br><span class="line"><span class="class"><span class="title">第一次调用object的方法时，会执行object的constructor，也就是执行object内部不在任何方法中的代码，因为它只有空参的构造函数</span></span></span><br><span class="line"><span class="class"><span class="title">但是注意，object的constructor的代码只会在他第一次被调用时执行一次，以后再次调用就不会再执行了</span></span></span><br><span class="line"><span class="class"><span class="title">object通常用于作为单例模式的实现，或者放class的一些静态成员，比如工具方法</span></span></span><br><span class="line"><span class="class"><span class="title">object可以直接使用，不能new</span></span></span><br><span class="line"><span class="class"><span class="title">创建一个object，使用object关键字</span></span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">1</span></span><br><span class="line">println(<span class="string">"this Person object!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAge</span> </span>= age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行，直接通过<span class="type">Object</span>的名称调用属性或者方法即可，类似于<span class="type">Java</span>中的静态类</span><br><span class="line">res18: <span class="type">Person</span><span class="class">.<span class="keyword">type</span> </span>= <span class="type">Person</span>$@<span class="number">73e776</span>b7</span><br><span class="line">scala&gt; <span class="type">Person</span>.age</span><br><span class="line">res19: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">scala&gt; <span class="type">Person</span>.getAge</span><br><span class="line">res20: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前面学习了class和object，那下面再来看一个特殊的概念，伴生对象</span><br><span class="line">如果有一个class，还有一个与class同名的object，那么就称这个object是class的 伴生对象 ，class是object的 伴生类</span><br><span class="line">注意：伴生类和伴生对象必须存放在一个.scala文件之中</span><br><span class="line">伴生类和伴生对象最大特点在于可以互相访问private field</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> fdNum= <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFdNum</span> </span>= fdNum</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span> </span>= println(<span class="string">"Hi, "</span> + name + <span class="string">",you are "</span> + age + <span class="string">" years old!"</span> +</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"tom"</span>,<span class="number">20</span>).sayHello</span><br><span class="line"><span class="type">Hi</span>, tom,you are <span class="number">20</span> years old!, and you have <span class="number">1</span> friend.</span><br><span class="line">scala&gt; <span class="type">Person</span>.fdNum</span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: value fdNum is not a member of <span class="class"><span class="keyword">object</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">Person</span>.<span class="title">fdNum</span></span></span><br><span class="line"><span class="class"><span class="title">^</span></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">Person</span>.<span class="title">getFdNum</span></span></span><br><span class="line"><span class="class"><span class="title">res26</span></span>: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply是object中非常重要的一个特殊方法，通常在伴生对象中实现apply方法，并在其中实现构造伴生类</span><br><span class="line">对象的功能</span><br><span class="line">在创建对象的时候，就不需要使用new Class的方式，而是使用Class()的方式，隐式调用伴生对象的apply方法，这样会让对象创建更加简洁</span><br><span class="line">例如：Array的伴生对象的apply方法就实现了接收可变数量的参数，以及会创建一个Array对象</span><br><span class="line">val a &#x3D; Array(1, 2, 3, 4, 5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">从Array object的源码中可以看出来，它里面就是在apply方法内部使用new Array创建的对象</span><br><span class="line">下面我们来自己定义一个伴生类和伴生对象</span><br><span class="line">class Person(val name: String)&#123;</span><br><span class="line">println(&quot;my name is,&quot;+name)</span><br><span class="line">&#125;</span><br><span class="line">object Person &#123;</span><br><span class="line">def apply(name: String) &#x3D; &#123;</span><br><span class="line">println(&quot;apply exec...&quot;)</span><br><span class="line">new Person(name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; new Person(&quot;tom&quot;)</span><br><span class="line">my name is,tom</span><br><span class="line">res29: Person &#x3D; Person@63917fe1</span><br><span class="line">scala&gt; Person(&quot;tom&quot;)</span><br><span class="line">apply exec...</span><br><span class="line">my name is,tom</span><br><span class="line">res30: Person &#x3D; Person@35e74e08</span><br><span class="line"></span><br><span class="line">注意：在这里new Person(“zhang”) 等于 Person(“zhang”)，都是获取Person的对象</span><br><span class="line">只不过Person(“zhang”)是用的object中apply方法</span><br><span class="line">而new Person(“zhang”)是直接基于class创建的</span><br></pre></td></tr></table></figure><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">接下来看一下scala中的main方法</span><br><span class="line">和Java一样，在Scala中如果要运行一个应用程序，必须有一个main方法，作为入口</span><br><span class="line">Scala中的main方法必须定义在object中，格式为 def main(args: Array[String])</span><br><span class="line">这就需要在编辑器中操作了，我们可以使用eclipse或者idea，但是eclipse对scala的支持不太好，所以建议使用idea</span><br><span class="line">首先确认一下idea中是否集成了scala语言插件</span><br><span class="line">打开idea，点击 configure--&gt;plugins</span><br><span class="line"></span><br><span class="line">确认scala的插件是否已经安装</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接着创建maven项目</span><br><span class="line"></span><br><span class="line">到这还没完，因为此时我们是无法创建scala代码的，这个项目中也没有集成scala的sdk，只有java的</span><br><span class="line">接下来就需要给这个项目添加scala的sdk了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以后再创建想要创建scala的maven项目，只需要进入到这个界面确认项目中是否有scala的依赖，没有的话直接点击右边的加号按钮添加即可</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好，idea的scala开发环境配置好了，但是我一般还是喜欢再增加一些配置</span><br><span class="line">目前项目的src目录下有一个java目录，这个目录表示是放java代码的，当然了你在里面写scala代码肯定</span><br><span class="line">是没有问题的。</span><br><span class="line">只是针对我这种稍微有点强迫症的用起来就有点别扭了</span><br><span class="line">在实际工作中可能我们一个项目既需要使用到java代码，也需要使用到scala代码，所以最好还是建议把</span><br><span class="line">java代码和scala代码分开存放，这样比较清晰</span><br><span class="line">所以我们需要在这里比葫芦画瓢，增加一个scala目录</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是注意了，这样创建的scala目录是有问题的，你有没有发现这个目录的颜色和java目录的颜色都不一样</span><br><span class="line">因为你在这直接创建的scala目录是一个普通的目录，而java那个目录是一个source根目录</span><br><span class="line">所以我们也需要把scala目录变为source根目录</span><br></pre></td></tr></table></figure><h3 id="接口-trait"><a href="#接口-trait" class="headerlink" title="接口-trait"></a>接口-trait</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接下来看一个scala中的接口，这个接口也是比较特殊的</span><br><span class="line">Scala中的接口称为trait，trait类似于Java中的interface</span><br><span class="line">在triat中可以定义抽象方法</span><br><span class="line">类可以使用 extends 关键字继承trait，无论继承类还是trait统一都是使用 extends 这个关键字</span><br><span class="line">类继承trait后，必须实现trait中的抽象方法，实现时不需要使用 override 关键字</span><br><span class="line">scala不支持对类进行多继承，但是支持对trait进行多重继承，使用 with 关键字即可</span><br><span class="line">下面我们就来看一个接口多继承的案例</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by xuwei</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"tom"</span>)</span><br><span class="line"><span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"jack"</span>)</span><br><span class="line">p1.sayHello(p2.name)</span><br><span class="line">p1.makeFriends(p2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HelloTrait</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MakeFriendsTrait</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">makeFriends</span></span>(p: <span class="type">Person</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">HelloTrait</span> <span class="keyword">with</span> <span class="title">MakeFriendsTrait</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name: <span class="type">String</span>) = println(<span class="string">"Hello, "</span> + name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeFriends</span></span>(p: <span class="type">Person</span>) = println(<span class="string">"Hello, my name is "</span> + name + <span class="string">", your name is"</span>+p.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="http://tianyong.fun/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第九周 第2章 Scala基础语法</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC2%E7%AB%A0-Scala%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC2%E7%AB%A0-Scala%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</id>
    <published>2022-02-28T06:18:55.000Z</published>
    <updated>2022-03-01T02:16:22.190Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第九周-第2章-Scala基础语法"><a href="#第九周-第2章-Scala基础语法" class="headerlink" title="第九周 第2章 Scala基础语法"></a>第九周 第2章 Scala基础语法</h1><h2 id="Scala的基本使用"><a href="#Scala的基本使用" class="headerlink" title="Scala的基本使用"></a>Scala的基本使用</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cala中的变量分为两种：可变 var 和 不可变 val</span><br><span class="line">可变var：可以随时修改var声明的变量的值</span><br><span class="line">不可变val：val声明的变量，值不能被修改，否则会报错： error: reassignment to val</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var a &#x3D; 1</span><br><span class="line">a: Int &#x3D; 1</span><br><span class="line">scala&gt; a &#x3D; 2</span><br><span class="line">a: Int &#x3D; 2</span><br><span class="line">scala&gt; val b &#x3D; 1</span><br><span class="line">b: Int &#x3D; 1</span><br><span class="line">scala&gt; b &#x3D; 2</span><br><span class="line">&lt;console&gt;:8: error: reassignment to val</span><br><span class="line">b &#x3D; 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注意：在实际工作中，针对一些不需要改变值的变量，通常建议使用val，这样可以不用担心值被错误的修改(等于java中的final类型)。这样可以提高系统的稳定性和健壮性！</span><br><span class="line"></span><br><span class="line">无论声明val变量，还是声明var变量，都可以手动指定变量的类型</span><br><span class="line">如果不指定，Scala会自动根据值，进行类型推断</span><br><span class="line">val c &#x3D; 1 等价于 val c: Int &#x3D; 1</span><br><span class="line"></span><br><span class="line">scala&gt; val c &#x3D; 1</span><br><span class="line">c: Int &#x3D; 1</span><br><span class="line">scala&gt; val c: Int &#x3D; 1</span><br><span class="line">c: Int &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Scala中的数据类型可以分为两种，基本数据类型和增强版数据类型</span><br><span class="line">基本数据类型有： Byte、Char、Short、Int、Long、Float、Double、Boolean</span><br><span class="line">增强版数据类型有： StringOps、RichInt、RichDouble、RichChar 等</span><br><span class="line">scala使用这些增强版数据类给基本数据类型增加了上百种增强的功能</span><br><span class="line">例如：RichInt提供的有一个to函数， 1.to(10) ，此处Int会先隐式转换为RichInt，然后再调用其to函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; 1.to(10)</span><br><span class="line">res2: scala.collection.immutable.Range.Inclusive &#x3D; Range(1, 2, 3, 4, 5, 6, 7,</span><br><span class="line"></span><br><span class="line">注意，to函数还可以这样写</span><br><span class="line">scala&gt; 1 to 10</span><br><span class="line">res3: scala.collection.immutable.Range.Inclusive &#x3D; Range(1, 2, 3, 4, 5, 6, 7,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用基本数据类型，直接就可以调用RichInt中对应的函数</span><br><span class="line">scala&gt; 1.toString() &#x2F;&#x2F;空号也可以不用</span><br><span class="line">res4: String &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scala的算术操作符与Java的算术操作符没有什么区别</span><br><span class="line">比如 +、-、*、&#x2F;、% 等，以及 &amp;、|、^、&gt;&gt;、&lt;&lt; 等</span><br><span class="line">注意：Scala中没有提供++、–操作符</span><br><span class="line">我们只能使用+和-，比如count &#x3D; 1，count++是错误的，必须写做count +&#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Scala中，if表达式是有返回值的，就是if或者else中最后一行语句返回的值，这一点和java中的if是不一样的，java中的if表达式是没有返回值的</span><br><span class="line"></span><br><span class="line">scala&gt; val age &#x3D; 20</span><br><span class="line">age: Int &#x3D; 20</span><br><span class="line">scala&gt; if(age &gt; 18) 1 else 0</span><br><span class="line">res9: Int &#x3D; 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在这因为if表达式是有返回值的，所以可以将if表达式赋予一个变量</span><br><span class="line"></span><br><span class="line">scala&gt; val res &#x3D; if(age &gt; 18) 1 else 0</span><br><span class="line">res: Int &#x3D; 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于if表达式是有值的，而if和else子句的值的类型可能还不一样，此时if表达式的值是什么类型呢？</span><br><span class="line">注意：Scala会自动进行推断，取两个类型的公共父类型</span><br><span class="line"></span><br><span class="line">例如，if(age &gt; 18) 1 else 0，表达式的类型是Int，因为1和0都是Int</span><br><span class="line">例如，if(age &gt; 18) “old” else 0，此时if和else的值分别是String和Int，则表达式的值是Any类型，Any是</span><br><span class="line">String和Int的公共父类型</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; if(age &gt; 18) 1 else 0</span><br><span class="line">res12: Int &#x3D; 1</span><br><span class="line">scala&gt; if(age &gt; 18) &quot;old&quot; else 0</span><br><span class="line">res13: Any &#x3D; old</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果if后面没有跟else，则默认else的值是Unit，也可以用()表示，类似于java中的void或者null</span><br><span class="line">例如，val age &#x3D; 12; if(age &gt; 18) “old”。此时就相当于if(age &gt; 18) “old” else ()。</span><br><span class="line">此时表达式的值是Any</span><br><span class="line"></span><br><span class="line">scala&gt; if(age &gt; 18) &quot;old&quot; else ()</span><br><span class="line">res17: Any &#x3D; ()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果想在scala REPL中执行多行代码，该如何操作？</span><br><span class="line">使用 :paste 和 ctrl+D 的方式</span><br><span class="line">:paste 表示代码块的开始</span><br><span class="line">ctrl+D 表示代码块的结束</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">val age &#x3D; 20</span><br><span class="line">if(age &gt; 18)</span><br><span class="line">1</span><br><span class="line">else</span><br><span class="line">0</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">age: Int &#x3D; 20</span><br><span class="line">res18: Int &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="语句终结符"><a href="#语句终结符" class="headerlink" title="语句终结符"></a>语句终结符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scala默认不需要语句终结符，它将每一行作为一个语句</span><br><span class="line">如果一行要放多条语句，则前面的语句必须使用语句终结符</span><br><span class="line">语句终结符和Java中的一样，就是我们平时使用的分号</span><br><span class="line"></span><br><span class="line">scala&gt; val age &#x3D; 20; if(age &gt; 18) 1 else 0</span><br><span class="line">age: Int &#x3D; 20</span><br><span class="line">res0: Int &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="print和println"><a href="#print和println" class="headerlink" title="print和println"></a>print和println</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在讲循环之前，先来看一下打印命令print和println</span><br><span class="line">print打印时不会加换行符，而println打印时会加一个换行符，这个特性和Java中的打印语句的特性是一样的</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for循环本身的特性就没什么好说的了，直接上案例，主要注意一下scala中的for和java中的for在语法层面的区别</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">val n &#x3D; 10</span><br><span class="line">for(i &lt;- 1 to n) &#x2F;&#x2F;1.to(n) 一样的</span><br><span class="line">println(i)</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">n: Int &#x3D; 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">这里面的to可以换成until</span><br><span class="line"></span><br><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">val n &#x3D; 10</span><br><span class="line">for(i &lt;- 1 until 10)</span><br><span class="line">println(i)</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5 </span><br><span class="line">6 </span><br><span class="line">7 </span><br><span class="line">8 </span><br><span class="line">9</span><br><span class="line">n: Int &#x3D; 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对比两次执行的结果发现</span><br><span class="line">1 to 10 可以获取1~10之间的所有数字</span><br><span class="line">1 until 10可以获取1~9之间的所有数字</span><br><span class="line"></span><br><span class="line">所以在这需要注意了，to 和 until 其实都是函数，一个是闭区间，一个是开区间</span><br><span class="line">具体用哪个就要看你的需求了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for循环针对字符串还可以用</span><br><span class="line">scala&gt; for(c &lt;- &quot;hello scala&quot;) println(c)</span><br><span class="line">h </span><br><span class="line">e </span><br><span class="line">l </span><br><span class="line">l </span><br><span class="line">o </span><br><span class="line">s </span><br><span class="line">c </span><br><span class="line">a </span><br><span class="line">l</span><br><span class="line">a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">注意：在这里我在for循环后面没有使用花括号，都省略了，主要是因为for循环的循环体代码就只有一行，如果有多行，就需要使用花括号了，否则，最终执行的结果就不是我们想要的</span><br><span class="line"></span><br><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">for(i &lt;- 1 to 5)</span><br><span class="line">println(i)</span><br><span class="line">println(&quot;hehe&quot;)</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4 </span><br><span class="line">5</span><br><span class="line">hehe</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while循环，它的用法和java中的while也是很像的，主要看一下语法层面的区别</span><br><span class="line"></span><br><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">var n &#x3D; 10</span><br><span class="line">while(n&gt;0)&#123;</span><br><span class="line">println(n)</span><br><span class="line">n -&#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">10</span><br><span class="line">9 </span><br><span class="line">8 </span><br><span class="line">7 </span><br><span class="line">6 </span><br><span class="line">5 </span><br><span class="line">4 </span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">1</span><br><span class="line">n: Int &#x3D; 0</span><br></pre></td></tr></table></figure><h4 id="高级for循环"><a href="#高级for循环" class="headerlink" title="高级for循环"></a>高级for循环</h4><h5 id="if守卫模式"><a href="#if守卫模式" class="headerlink" title="if守卫模式"></a>if守卫模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最后来看一下高级for循环的用法</span><br><span class="line">if守卫</span><br><span class="line">if守卫模式，假设我们想要获取1~10之间的所有偶数，使用普通的for循环，需要把每一个数字都循环出来，然后判断是否是偶数</span><br><span class="line">如果在for循环里面使用if守卫，可以在循环的时候就执行一定的逻辑，判断数值是否是偶数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; for(i &lt;- 1 to 10 if i % 2 &#x3D;&#x3D; 0) println(i)</span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">6 </span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h5 id="for推导式"><a href="#for推导式" class="headerlink" title="for推导式"></a>for推导式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for推导式，一个典型例子是构造集合</span><br><span class="line"></span><br><span class="line">我们在使用for循环迭代数字的时候，可以使用yield指定一个规则，对迭代出来的数字进行处理，并且创建一个新的集合</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- 1 to 10) yield i *2</span><br><span class="line">res16: scala.collection.immutable.IndexedSeq[Int] &#x3D; Vector(2, 4, 6, 8, 10, 12</span><br></pre></td></tr></table></figure><h3 id="Scala的集合体系"><a href="#Scala的集合体系" class="headerlink" title="Scala的集合体系"></a>Scala的集合体系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来整体学习一下Scala中的集合体系，集合在工作中属于经常使用的数据结构</span><br></pre></td></tr></table></figure><h4 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先看一下整个集合体系结构，这个结构与Java的集合体系非常相似</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/bKJxIg" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/02/28/bKJxIg.md.png" alt="bKJxIg.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">集合的顶层接口是Iterable，Iterable接口下面还有一些子接口， Set、Seq、Map</span><br><span class="line">这几个子接口下面有具体的实现类</span><br><span class="line">set下面有HashSet、LinkedHashSet、SortedSet等等</span><br><span class="line">seq下面有List、Buffer、Range等等</span><br><span class="line">Map下面有HashMap、SortedMap、LinkedHashMap等等</span><br><span class="line">其中Buffer下面还有两个常用的，ArrayBuffer、ListBuffer</span><br><span class="line">这是集合中一些常见的实现类</span><br><span class="line">在讲这个集合体系的时候，还会关联讲到 Array和Tuple 这两个数据结构</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scala中的集合是分成可变和不可变两类集合的</span><br><span class="line">其中可变集合就是说，集合的元素可以动态修改</span><br><span class="line">而不可变集合就是说，集合的元素在初始化之后，就无法修改了</span><br><span class="line">可变集合：在 scala.collection.mutable 这个包下面</span><br><span class="line">不可变集合：在 scala.collection.immutable 这个包下面</span><br><span class="line">我们在创建集合的时候，如果不指定具体的包名，默认会使用不可变集合</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先来看一下Set，Set代表一个没有重复元素的集合</span><br><span class="line">这个集合的特性和Java中Set集合的特性基本一样</span><br><span class="line">Set集合分为可变的和不可变的集合，默认情况下使用的是不可变集合</span><br><span class="line">Set可以直接使用，并且不需要使用new关键字，来看一下</span><br><span class="line"></span><br><span class="line">scala&gt; val s &#x3D; Set(1,2,3)</span><br><span class="line">s: scala.collection.immutable.Set[Int] &#x3D; Set(1, 2, 3)</span><br></pre></td></tr></table></figure><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><h6 id="不可变set"><a href="#不可变set" class="headerlink" title="不可变set"></a>不可变set</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是不是很奇怪，本来Set是一个接口，但是却可以创建对象，更神奇的是竟然还不需要使用new关键</span><br><span class="line">字，这就有点颠覆我们的认知了</span><br><span class="line">注意了，大家在学习Scala的时候，可以拿Java来进行对比，加深理解，但是不要全部拿Java里面的知识点来硬套，因为它们两个有些地方还是不一样的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">来看一下Scala的文档，你会发现这个Set不仅仅是一个接口，它还是一个Object，具体这个Object类型我</span><br><span class="line">们在后面会详细分析，在这大家先知道这个东西就行了。</span><br><span class="line"></span><br><span class="line">注意：本来是应该看对应版本2.12.11的文档的，但是2.12.11文档的格式看起来不是很清晰，所以在这我们就是要2.11.12这个版本了，主要的是没有什么变化的，不影响我们使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在这大家可以这样理解，只要前面带有object的，可以直接创建对象，并且不需要使用new关键字</span><br><span class="line">所以set可以直接使用</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意：默认情况下直接创建的set集合是一个不可变集合，在这可以看到是在immutable包里面的，不可变集合中的元素一经初始化，就不能改变了，所以初始化后再向里面添加元素就报错了</span><br><span class="line"></span><br><span class="line">scala&gt; val s &#x3D; Set(1,2,3)</span><br><span class="line">s: scala.collection.immutable.Set[Int] &#x3D; Set(1, 2, 3)</span><br><span class="line">scala&gt; s +&#x3D; 4</span><br><span class="line">&lt;console&gt;:9: error: value +&#x3D; is not a member of scala.collection.immutable.Set</span><br><span class="line">s +&#x3D; 4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">但是注意，我使用s + 4 这种操作是可以的</span><br><span class="line">scala&gt; val s &#x3D; Set(1,2,3)</span><br><span class="line">s: scala.collection.immutable.Set[Int] &#x3D; Set(1, 2, 3)</span><br><span class="line">scala&gt; s + 4</span><br><span class="line">res33: scala.collection.immutable.Set[Int] &#x3D; Set(1, 2, 3, 4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这样是不是和我们刚才说的自相矛盾？</span><br><span class="line">不是的，因为 s + 4 返回的是一个新的集合了，相当于在之前的集合的基础上，创建一个新的集合，新的集合包含之前集合的元素和我们新增的4这个元素</span><br><span class="line">这个大家需要能够区分开</span><br></pre></td></tr></table></figure><h6 id="可变set"><a href="#可变set" class="headerlink" title="可变set"></a>可变set</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果想要创建一个可变的set集合，可以使用mutable包下面的set集合，显式指定包名</span><br><span class="line"></span><br><span class="line">scala&gt; val s &#x3D; scala.collection.mutable.Set(1,2,3)</span><br><span class="line">s: scala.collection.mutable.Set[Int] &#x3D; Set(1, 2, 3)</span><br><span class="line">scala&gt; s +&#x3D; 4</span><br><span class="line">res34: s.type &#x3D; Set(1, 2, 3, 4)</span><br><span class="line"> 12345</span><br></pre></td></tr></table></figure><h6 id="子类HashSet"><a href="#子类HashSet" class="headerlink" title="子类HashSet"></a>子类HashSet</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashSet：这个集合的特点是：集合中的元素不重复、无序</span><br><span class="line"></span><br><span class="line">HashSet集合分为可变和不可变之分， immutable 包下面的是不可变的，后期无法新增元素</span><br><span class="line">在这里可以使用new关键字，也可以不使用，因为HashSet既是class，又是object，但是包名需要指定，否则无法识别</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val s &#x3D; new scala.collection.mutable.HashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.HashSet[Int] &#x3D; Set()</span><br><span class="line">scala&gt; s +&#x3D;1</span><br><span class="line">res35: s.type &#x3D; Set(1)</span><br><span class="line">scala&gt; s +&#x3D;2</span><br><span class="line">res36: s.type &#x3D; Set(1, 2)</span><br><span class="line">scala&gt; s +&#x3D;5 &#x2F;&#x2F;＋&#x3D;是一个方法，s.+&#x3D;(5)一样</span><br><span class="line">res38: s.type &#x3D; Set(1, 5, 2)</span><br><span class="line"></span><br><span class="line">如果在创建集合的时候就初始化了元素，则可以省略泛型的定义，集合会自动识别元素的类型</span><br></pre></td></tr></table></figure><h6 id="子类LinkedHashSet"><a href="#子类LinkedHashSet" class="headerlink" title="子类LinkedHashSet"></a>子类LinkedHashSet</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet：这个集合的特点是：集合中的元素不重复、有序，它会用一个链表维护插入顺序，可以保证集合中元素是有序的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet只有可变的，没有不可变的</span><br><span class="line"></span><br><span class="line">scala&gt; val s &#x3D; new scala.collection.mutable.LinkedHashSet[Int]()</span><br><span class="line">s: scala.collection.mutable.LinkedHashSet[Int] &#x3D; Set()</span><br><span class="line">scala&gt; s +&#x3D;1</span><br><span class="line">res42: s.type &#x3D; Set(1)</span><br><span class="line">scala&gt; s +&#x3D;2</span><br><span class="line">res43: s.type &#x3D; Set(1, 2)</span><br><span class="line">scala&gt; s +&#x3D;5</span><br><span class="line">res44: s.type &#x3D; Set(1, 2, 5)</span><br></pre></td></tr></table></figure><h6 id="子类SortedSet"><a href="#子类SortedSet" class="headerlink" title="子类SortedSet"></a>子类SortedSet</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SortedSet：这个集合的特点是：集合中的元素不重复、有序，它会自动根据元素来进行排序</span><br><span class="line"></span><br><span class="line">SortedSet分为可变集合和不可变集合</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/bKDyTI" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/02/28/bKDyTI.md.png" alt="bKDyTI.md.png"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面的那两个SortedSet是上面collection.SortedSet接口的子接口，一般会使用下面那两个。</span><br><span class="line"></span><br><span class="line">scala&gt; val s &#x3D; scala.collection.mutable.SortedSet[String]()</span><br><span class="line">s: scala.collection.mutable.SortedSet[String] &#x3D; TreeSet()</span><br><span class="line">scala&gt; s +&#x3D;(&quot;c&quot;)</span><br><span class="line">res45: s.type &#x3D; TreeSet(c)</span><br><span class="line">scala&gt; s +&#x3D;(&quot;a&quot;)</span><br><span class="line">res46: s.type &#x3D; TreeSet(a, c)</span><br><span class="line">scala&gt; s +&#x3D;(&quot;b&quot;)</span><br><span class="line">res47: s.type &#x3D; TreeSet(a, b, c)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从这可以看出来SortedSet集合中的元素是按照元素的字典顺序排序的</span><br><span class="line">针对里面这些Set集合，如果想要迭代他们里面的元素，可以使用for循环直接迭代</span><br><span class="line">以SortedSet为例，其它的 Set、HashSet、LinkedHashSet 都是一样的</span><br><span class="line"></span><br><span class="line">scala&gt; for(i &lt;- s ) println(i)</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接下来看一下List，List属于Seq接口的子接口</span><br><span class="line">List代表一个不可变的列表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建一个list</span><br><span class="line">scala&gt; val l &#x3D; List(1, 2, 3, 4)</span><br><span class="line">l: List[Int] &#x3D; List(1, 2, 3, 4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：为什么有的地方需要写类的全路径，而有的不需要呢？</span><br><span class="line">由于immutable包是默认导入的，所以不需要导包，但是也会有个别虽然在immutable包下面的，但是不写全路径还是报错，原谅它把，反正你都带全路径肯定是没有问题的，后期我们会使用idea来开发，也不需要考虑包名的问题，不过在这为了演示起来更加清晰，就使用scala的命令行了</span><br></pre></td></tr></table></figure><h6 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">针对List有 head 、 tail 以及 :: 这几个操作</span><br><span class="line">先演示一下 head、tail 操作</span><br><span class="line"></span><br><span class="line">scala&gt; l.head</span><br><span class="line">res49: Int &#x3D; 1</span><br><span class="line">scala&gt; l.tail</span><br><span class="line">res51: List[Int] &#x3D; List(2, 3, 4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head：表示获取List中的第一个元素</span><br><span class="line">tail：表示获取List中第一个元素之后的所有元素</span><br><span class="line">那其实head和tail就可以获取list中的所有元素了</span><br></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title=": :"></a>: :</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过 :: 操作符，可以将head和tail的结果合并成一个List</span><br><span class="line"></span><br><span class="line">scala&gt; l.head :: l.tail</span><br><span class="line">res52: List[Int] &#x3D; List(1, 2, 3, 4)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:: 这种操作符要清楚，在spark源码中是有体现的，一定要能够看懂</span><br><span class="line"></span><br><span class="line">针对List中的元素进行迭代和前面讲的Set集合的迭代是一样的</span><br></pre></td></tr></table></figure><h5 id="ListBuffer"><a href="#ListBuffer" class="headerlink" title="ListBuffer"></a>ListBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在这里List是不可变的列表，在实际工作中使用的时候会很不方便，因为我们很多场景下都是需要向列表中动态添加元素，这个时候该怎么办呢？</span><br><span class="line">Scala还提供的有一个ListBuffer</span><br><span class="line">ListBuffer：可以支持动态增加或者移除元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val lb &#x3D; scala.collection.mutable.ListBuffer[Int]()</span><br><span class="line">lb: scala.collection.mutable.ListBuffer[Int] &#x3D; ListBuffer()</span><br><span class="line">scala&gt; lb +&#x3D;1</span><br><span class="line">res56: lb.type &#x3D; ListBuffer(1)</span><br><span class="line">scala&gt; lb +&#x3D;2</span><br><span class="line">res57: lb.type &#x3D; ListBuffer(1, 2)</span><br><span class="line">scala&gt; lb +&#x3D;5</span><br><span class="line">res58: lb.type &#x3D; ListBuffer(1, 2, 5)</span><br><span class="line">scala&gt; lb -&#x3D;5</span><br><span class="line">res59: lb.type &#x3D; ListBuffer(1, 2)</span><br><span class="line"></span><br><span class="line">ListBuffer也可以直接使用for循环迭代</span><br></pre></td></tr></table></figure><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map是一种可迭代的键值对（key&#x2F;value）结构</span><br><span class="line">Map分为可变和不可变，默认情况下使用的是不可变Map</span><br></pre></td></tr></table></figure><h6 id="不可变Map"><a href="#不可变Map" class="headerlink" title="不可变Map"></a>不可变Map</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">创建一个不可变的Map</span><br><span class="line">创建一个可变的Map</span><br><span class="line">还有一种创建Map的简易方式，这种方式创建的是不可变Map</span><br><span class="line">查询操作</span><br><span class="line">获取指定key对应的value，如果key不存在，会报错</span><br><span class="line">所以在实际工作中这样直接获取不太好，如果遇到了不存在的key程序会报错，导致程序异常退出。</span><br><span class="line">那是不是可以考虑在获取key的值之前，先判断key是否存在</span><br><span class="line">可以使用contains函数检查key是否存在、</span><br><span class="line">使用if-else语句，如果指定的key不存在，则返回一个默认值</span><br><span class="line">这样是没问题的，就是写起来有点麻烦了，有没有方便一点的用法呢？</span><br><span class="line">map中还有一个getOrElse函数</span><br><span class="line">scala&gt; val ages &#x3D; Map(&quot;jack&quot;-&gt;30,&quot;tom&quot;-&gt;25,&quot;jessic&quot;-&gt;23)</span><br><span class="line">ages: scala.collection.immutable.Map[String,Int] &#x3D; Map(jack -&gt; 30, tom -&gt; 25,</span><br><span class="line">scala&gt; ages(&quot;jack&quot;)</span><br><span class="line">res100: Int &#x3D; 30</span><br></pre></td></tr></table></figure><h6 id="可变Map"><a href="#可变Map" class="headerlink" title="可变Map"></a>可变Map</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val ages &#x3D; scala.collection.mutable.Map(&quot;jack&quot;-&gt;30,&quot;tom&quot;-&gt;25,&quot;jessic&quot;-</span><br><span class="line">ages: scala.collection.mutable.Map[String,Int] &#x3D; Map(jessic -&gt; 23, jack -&gt; 30</span><br><span class="line">scala&gt; ages(&quot;jack&quot;)</span><br><span class="line">res101: Int &#x3D; 30</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还有一种创建Map的简易方式，这种方式创建的是不可变Map</span><br><span class="line"></span><br><span class="line">scala&gt; val ages &#x3D; Map((&quot;jack&quot;,30),(&quot;tom&quot;,25),(&quot;jessic&quot;-&gt;23))</span><br><span class="line">ages: scala.collection.immutable.Map[String,Int] &#x3D; Map(jack -&gt; 30, tom -&gt; 25,</span><br></pre></td></tr></table></figure><h6 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.获取指定key对应的value，如果key不存在，会报错</span><br><span class="line"></span><br><span class="line">scala&gt; val ages &#x3D; scala.collection.mutable.Map((&quot;jack&quot;,30),(&quot;tom&quot;,25),(&quot;jessi</span><br><span class="line">ages: scala.collection.mutable.Map[String,Int] &#x3D; Map(jessic -&gt; 23, jack -&gt; 30</span><br><span class="line">scala&gt; val age &#x3D; ages(&quot;jack&quot;)</span><br><span class="line">age: Int &#x3D; 30</span><br><span class="line">scala&gt; val age &#x3D; ages(&quot;jack1&quot;)</span><br><span class="line">java.util.NoSuchElementException: key not found: jack</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">所以在实际工作中这样直接获取不太好，如果遇到了不存在的key程序会报错，导致程序异常退出。</span><br><span class="line">那是不是可以考虑在获取key的值之前，先判断key是否存在</span><br><span class="line">可以使用contains函数检查key是否存在、</span><br><span class="line">使用if-else语句，如果指定的key不存在，则返回一个默认值</span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">scala&gt; val age &#x3D; if (ages.contains(&quot;jack1&quot;)) ages(&quot;jack1&quot;) else 0</span><br><span class="line">age: Int &#x3D; 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样是没问题的，就是写起来有点麻烦了，有没有方便一点的用法呢？</span><br><span class="line">map中还有一个getOrElse函数</span><br><span class="line">3.</span><br><span class="line">scala&gt; val age &#x3D; ages.getOrElse(&quot;jack1&quot;, 0)</span><br><span class="line">age: Int &#x3D; 0</span><br><span class="line"></span><br><span class="line">建议后期从map中获取数据都使用这个 getOrElse 函数</span><br></pre></td></tr></table></figure><h6 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.更新map中的元素(首先确保创建时使用的是mutable)</span><br><span class="line">scala&gt; ages(&quot;jack&quot;) &#x3D; 31</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.增加多个元素</span><br><span class="line">scala&gt; ages +&#x3D; (&quot;hehe&quot; -&gt; 35, &quot;haha&quot; -&gt; 40)</span><br><span class="line">res105: ages.type &#x3D; Map(hehe -&gt; 35, jessic -&gt; 23, jack -&gt; 31, tom -&gt; 25, haha</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.移除元素</span><br><span class="line">scala&gt; ages -&#x3D; &quot;hehe&quot;</span><br><span class="line">res106: ages.type &#x3D; Map(jessic -&gt; 23, jack -&gt; 31, tom -&gt; 25, haha -&gt; 40)</span><br></pre></td></tr></table></figure><h6 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.遍历map的entrySet</span><br><span class="line">scala&gt; for ((key, value) &lt;- ages) println(key + &quot; &quot; + value)</span><br><span class="line">jessic 23</span><br><span class="line">jack 31</span><br><span class="line">tom 25</span><br><span class="line">haha 40</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.遍历map的key</span><br><span class="line">scala&gt; for (key &lt;- ages.keySet) println(key)</span><br><span class="line">jessic</span><br><span class="line">jack</span><br><span class="line">tom</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.遍历map的value</span><br><span class="line">scala&gt; for (value &lt;- ages.values) println(value)</span><br><span class="line">23</span><br><span class="line">31</span><br><span class="line">25</span><br><span class="line">40</span><br></pre></td></tr></table></figure><h6 id="子类HashMap"><a href="#子类HashMap" class="headerlink" title="子类HashMap"></a>子类HashMap</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap：是一个按照key的hash值进行排列存储的map</span><br></pre></td></tr></table></figure><h6 id="子类SortedMap"><a href="#子类SortedMap" class="headerlink" title="子类SortedMap"></a>子类SortedMap</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap：可以自动对Map中的key进行排序【有序的map】</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap分为可变和不可变的，没有什么特殊之处</span><br><span class="line">在这主要演示一下SortedMap和LinkedHashMap</span><br><span class="line">SortedMap是不可变的</span><br><span class="line"></span><br><span class="line">scala&gt; val ages &#x3D; scala.collection.immutable.SortedMap(&quot;b&quot; -&gt; 30, &quot;a&quot; -&gt; 15,</span><br><span class="line">ages: scala.collection.immutable.SortedMap[String,Int] &#x3D; Map(a -&gt; 15, b -&gt; 30</span><br></pre></td></tr></table></figure><h6 id="子类LinkedHashMap"><a href="#子类LinkedHashMap" class="headerlink" title="子类LinkedHashMap"></a>子类LinkedHashMap</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap：可以记住插入的key-value的顺序</span><br><span class="line"></span><br><span class="line">LinkedHashMap是可变的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val ages &#x3D; new scala.collection.mutable.LinkedHashMap[String, Int]()</span><br><span class="line">ages: scala.collection.mutable.LinkedHashMap[String,Int] &#x3D; Map()</span><br><span class="line">scala&gt; ages(&quot;b&quot;)&#x3D;30</span><br><span class="line">scala&gt; ages(&quot;a&quot;)&#x3D;15</span><br><span class="line">scala&gt; ages(&quot;c&quot;)&#x3D;25</span><br><span class="line">scala&gt; ages</span><br><span class="line">res116: scala.collection.mutable.LinkedHashMap[String,Int] &#x3D; Map(b -&gt; 30, a</span><br></pre></td></tr></table></figure><h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scala中Array的含义与Java中的数组类似，长度不可变</span><br><span class="line">由于Scala和Java都是运行在JVM中，双方可以互相调用，因此Scala数组的底层实际上就是Java数组</span><br><span class="line">数组初始化后，长度就固定下来了，而且元素全部根据其类型进行初始化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val a &#x3D; new Array[Int](10)</span><br><span class="line">a: Array[Int] &#x3D; Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</span><br><span class="line">scala&gt; a(0)</span><br><span class="line">res65: Int &#x3D; 0</span><br><span class="line">scala&gt; a(0)&#x3D;1</span><br><span class="line">scala&gt; a(0)</span><br><span class="line">res67: Int &#x3D; 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">也可以直接使用Array()创建数组，元素类型自动推断</span><br><span class="line">scala&gt; val a &#x3D; Array(&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">a: Array[String] &#x3D; Array(hello, world)</span><br><span class="line"></span><br><span class="line">scala&gt; a(0)</span><br><span class="line">res68: String &#x3D; hello</span><br><span class="line">scala&gt; val a1 &#x3D; Array(&quot;hello&quot;, 30)</span><br><span class="line">a1: Array[Any] &#x3D; Array(hello, 30)</span><br></pre></td></tr></table></figure><h5 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Scala中ArrayBuffer与Java中的ArrayList类似，长度可变</span><br><span class="line">ArrayBuffer：添加元素、移除元素</span><br><span class="line">如果不想每次都使用全限定名，则可以预先导入ArrayBuffer类</span><br><span class="line"></span><br><span class="line">scala&gt; import scala.collection.mutable.ArrayBuffer</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用ArrayBuffer()的方式可以创建一个空的ArrayBuffer</span><br><span class="line">注意：也支持直接创建并且初始化ArrayBuffer(1,2,3,4)</span><br><span class="line"></span><br><span class="line">scala&gt; val b &#x3D; new ArrayBuffer[Int]()</span><br></pre></td></tr></table></figure><h6 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.使用+&#x3D;操作符，可以添加一个元素，或者多个元素</span><br><span class="line">b +&#x3D; 1 或者 b +&#x3D; (2, 3, 4, 5)</span><br><span class="line"></span><br><span class="line">2.使用insert()函数可以在指定位置插入元素，但是这种操作效率很低，因为需要移动指定位置后的所有元素 向3号角标的位置添加一个元素 30</span><br><span class="line">scala&gt; b.insert(3,30)</span><br></pre></td></tr></table></figure><h6 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 remove() 函数可以移除指定位置的元素</span><br><span class="line">移除1号角标的元素</span><br><span class="line">scala&gt; b.remove(1)</span><br><span class="line">res73: Int &#x3D; 2</span><br></pre></td></tr></table></figure><h6 id="Array和ArrayBuffer转化"><a href="#Array和ArrayBuffer转化" class="headerlink" title="Array和ArrayBuffer转化"></a>Array和ArrayBuffer转化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.toArray：ArrayBuffer转Array</span><br><span class="line">a.toBuffer：Array转ArrayBuffer</span><br></pre></td></tr></table></figure><h5 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面看一下针对数据的常见操作</span><br><span class="line">遍历Array和ArrayBuffer的两种方式</span><br><span class="line">由于Array和ArrayBuffer都是有角标的，所以在迭代数组中元素的时候除了可以使用前面迭代集合的方式还可以使用角标迭代</span><br></pre></td></tr></table></figure><h6 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.scala&gt; for(i &lt;- b) println(i)</span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.scala&gt; for(i &lt;- 0 until b.length ) println(b(i))</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h6 id="求和，最大值"><a href="#求和，最大值" class="headerlink" title="求和，最大值"></a>求和，最大值</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val sum &#x3D; a.sum</span><br><span class="line">sum: Int &#x3D; 15</span><br><span class="line">scala&gt; val max &#x3D; a.max</span><br><span class="line">max: Int &#x3D; 5</span><br></pre></td></tr></table></figure><h6 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; scala.util.Sorting.quickSort(a)</span><br></pre></td></tr></table></figure><h5 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tuple：称之为元组，它与Array类似，都是不可变的，但与数组不同的是元组可以包含不同类型的元素</span><br><span class="line">Tuple中的元素角标从 1 开始</span><br><span class="line"></span><br><span class="line">注意：目前 Scala 支持的元组最大长度为 22 ，对于更大长度可以使用集合或数组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val t &#x3D; (1, 3.14, &quot;hehe&quot;)</span><br><span class="line">t: (Int, Double, String) &#x3D; (1,3.14,hehe)</span><br><span class="line">scala&gt; t._1</span><br><span class="line">res117: Int &#x3D; 1</span><br><span class="line">scala&gt; t._3</span><br><span class="line">res118: String &#x3D; hehe</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前面讲了很多集合体系中的数据结构，有的是可变的，有的是不可变的，有的是既是可变的又是不可变的，听起来有点乱，在这里我们总结一下</span><br><span class="line">可变集合： LinkedHashSet、ListBuffer、ArrayBuffer、LinkedHashMap</span><br><span class="line">不可变集合： List、SortedMap</span><br><span class="line">可变+不可变集合： Set、HashSet、SortedSet、Map、HashMap</span><br><span class="line">还有两个编外人员：</span><br><span class="line">Array、Tuple</span><br><span class="line">Array：长度不可变，里面的元素可变</span><br><span class="line">Tuple：长度不可变，里面的元素也不可变</span><br></pre></td></tr></table></figure><h3 id="Scala中函数的使用"><a href="#Scala中函数的使用" class="headerlink" title="Scala中函数的使用"></a>Scala中函数的使用</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先来看一下函数的定义</span><br><span class="line">在Scala中定义函数需要使用 def 关键字，函数包括函数名、参数、函数体</span><br><span class="line">Scala要求必须给出函数所有参数的类型，但是函数返回值的类型不是必须的，因为Scala可以自己根据函数体中的表达式推断出返回值类型。</span><br><span class="line">函数中最后一行代码的返回值就是整个函数的返回值，不需要使用return，这一点与Java不同，java中函数的返回值是必须要使用return的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单行函数</span><br><span class="line">scala&gt; def sayHello(name: String) &#x3D; print(&quot;Hello, &quot; + name)</span><br><span class="line">sayHello: (name: String)Unit</span><br><span class="line">scala&gt; sayHello(&quot;Scala&quot;)</span><br><span class="line">Hello, Scala</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多行函数</span><br><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">def sayHello(name: String, age: Int) &#x3D; &#123;</span><br><span class="line">println(&quot;My name is &quot;+name+&quot;,age is &quot;+age)</span><br><span class="line">age</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">sayHello: (name: String, age: Int)Int</span><br><span class="line">scala&gt; sayHello(&quot;Scala&quot;,18)</span><br><span class="line">My name is Scala,age is 18</span><br><span class="line">res120: Int &#x3D; 18</span><br></pre></td></tr></table></figure><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Scala中，有时候我们调用某些函数时，不希望给出参数的具体值，而是希望使用参数自身默认的值，此时就需要在定义函数时使用默认参数。</span><br><span class="line">如果给出的参数不够，则会从左往右依次应用参数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def sayHello(fName: String, mName: String &#x3D; &quot;mid&quot;, lName: String &#x3D; &quot;la</span><br><span class="line">sayHello: (fName: String, mName: String, lName: String)String</span><br><span class="line">scala&gt; sayHello(&quot;zhang&quot;,&quot;san&quot;)</span><br><span class="line">res122: String &#x3D; zhang san last</span><br></pre></td></tr></table></figure><h5 id="带名参数"><a href="#带名参数" class="headerlink" title="带名参数"></a>带名参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在调用函数时，也可以不按照函数定义的参数顺序来传递参数，而是使用带名参数的方式来传递。</span><br><span class="line">scala&gt; def sayHello(fName: String, mName: String &#x3D; &quot;mid&quot;, lName: String &#x3D; &quot;la</span><br><span class="line">sayHello: (fName: String, mName: String, lName: String)String</span><br><span class="line">scala&gt; sayHello(fName &#x3D; &quot;Mick&quot;, lName &#x3D; &quot;Tom&quot;, mName &#x3D; &quot;Jack&quot;)</span><br><span class="line">res127: String &#x3D; Mick Jack Tom</span><br></pre></td></tr></table></figure><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在Scala中，有时我们需要将函数定义为参数个数可变的形式，则此时可以使用变长参数来定义函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; :paste</span><br><span class="line">&#x2F;&#x2F; Entering paste mode (ctrl-D to finish)</span><br><span class="line">def sum(nums: Int*) &#x3D; &#123;  &#x2F;&#x2F;Int的I要大写</span><br><span class="line">var res &#x3D; 0</span><br><span class="line">for (num &lt;- nums) res +&#x3D; num</span><br><span class="line">res</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Exiting paste mode, now interpreting.</span><br><span class="line">sum: (nums: Int*)Int</span><br><span class="line">scala&gt; sum(1,2,3,4,5)</span><br><span class="line">res129: Int &#x3D; 15</span><br></pre></td></tr></table></figure><h4 id="特殊的函数-过程"><a href="#特殊的函数-过程" class="headerlink" title="特殊的函数-过程"></a>特殊的函数-过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在Scala中，定义函数时，如果函数体直接在花括号里面而没有使用&#x3D;连接，则函数的返回值类型就是Unit，这样的函数称之为过程</span><br><span class="line">过程通常用于不需要返回值的函数</span><br><span class="line">过程还有一种写法，就是将函数的返回值类型显式定义为Unit</span><br><span class="line">比较一下这四种写法的区别</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有返回值</span><br><span class="line">def sayHello(name: String) &#x3D; &quot;Hello, &quot; + name</span><br><span class="line">def sayHello(name: String): String &#x3D; &quot;Hello, &quot; + name</span><br><span class="line"></span><br><span class="line">无返回值</span><br><span class="line">def sayHello(name: String) &#123; &quot;Hello, &quot; + name &#125;</span><br><span class="line">def sayHello(name: String): Unit &#x3D; &quot;Hello, &quot; + name</span><br><span class="line"></span><br><span class="line">前面两种写法的效果是一样的，都是函数</span><br><span class="line">后面两种写法的效果是一样的，都是过程</span><br></pre></td></tr></table></figure><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scala提供了lazy特性，如果将一个变量声明为lazy，则只有在第一次使用该变量时，变量对应的表达式才会发生计算</span><br><span class="line">什么场景下需要使用lazy特性呢？</span><br><span class="line">这种特性对于特别耗时的操作特别有用，比如打开文件这个操作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; import scala.io.Source._</span><br><span class="line">import scala.io.Source._</span><br><span class="line">scala&gt; lazy val lines &#x3D; fromFile(&quot;D:&#x2F;&#x2F;test.txt&quot;).mkString</span><br><span class="line">lines: String &#x3D; &lt;lazy&gt;</span><br><span class="line"></span><br><span class="line">即使D:&#x2F;&#x2F;test.txt文件不存在，代码也不会报错，只有变量使用时才会报错，这就是lazy这个特性</span><br><span class="line">scala&gt; lines</span><br><span class="line">java.io.FileNotFoundException: D:\test.txt (系统找不到指定的文件。)</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><h4 id="用法积累"><a href="#用法积累" class="headerlink" title="用法积累"></a>用法积累</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.字符串不能用单引号代替双引号</span><br><span class="line">2.过程不用等号那种形式时，语句只能放在花括号里</span><br><span class="line">3.数据类型Int的I只能大写</span><br><span class="line">4.只能lazy val xxx；不能lazy var</span><br><span class="line">5</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="http://tianyong.fun/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第九周 第1章 Scala极速入门</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC1%E7%AB%A0-Scala%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B9%9D%E5%91%A8-%E7%AC%AC1%E7%AB%A0-Scala%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8.html</id>
    <published>2022-02-28T06:16:58.000Z</published>
    <updated>2022-02-28T06:35:48.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第九周-第1章-Scala极速入门"><a href="#第九周-第1章-Scala极速入门" class="headerlink" title="第九周 第1章 Scala极速入门"></a>第九周 第1章 Scala极速入门</h1><h2 id="为什么要学习Scala语言"><a href="#为什么要学习Scala语言" class="headerlink" title="为什么要学习Scala语言"></a>为什么要学习Scala语言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先我们来分析一下为什么要学习Scala语言</span><br><span class="line">最直接的一点就是因为我们后面要学的Spark框架需要用到Scala这门语言</span><br><span class="line">但是Spark其实是同时支持Scala语言和Java语言的，为什么非要学Scala呢，使用java它难道不香吗？</span><br><span class="line">这就要说第二点了：看下面的代码，使用Spark统计文件内单词出现的次数这个需求，使用java代码和scala代码的区别是有多么的明显，在代码量上来说，scala是完胜java的，所以在实际工作中开发spark代码，我们都是需要使用scala的，使用java实现函数式编程太别扭了，代码量太大，这个就是我们学习</span><br><span class="line">scala的最直接的原因</span><br></pre></td></tr></table></figure><h2 id="什么是Scala"><a href="#什么是Scala" class="headerlink" title="什么是Scala"></a>什么是Scala</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scala是一门多范式的编程语言，它是一种类似Java的编程语言，它设计的初衷是为了实现可伸缩的语言、并集成面向对象编程和函数式编程的各种特性</span><br><span class="line">Scala基于Java虚拟机，也就是基于JVM的一门编程语言。所有Scala代码，都需要编译为字节码，然后交由Java虚拟机来运行</span><br><span class="line">Scala和Java可以无缝相互操作，Scala可以任意调用Java代码，这个特性是非常好的</span><br></pre></td></tr></table></figure><h2 id="如何快速掌握Scala语言"><a href="#如何快速掌握Scala语言" class="headerlink" title="如何快速掌握Scala语言"></a>如何快速掌握Scala语言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这先给大家打个预防针，虽然前面我们说了使用scala实现spark代码会很简洁，但是scala语言本身是</span><br><span class="line">很反人类的，特别是你熟悉了例如java之类的编程语言之后再来学scala，会感觉到既爱又恨</span><br><span class="line">那我们如何快速掌握Scala语言的使用呢？</span><br><span class="line">首先大家在学习的过程中需要对比分析Java和Scala在使用上的区别，这样可以加深我们的理解</span><br><span class="line">然后没事的时候可以尝试着用Scala代码改写你之前的Java代码</span><br><span class="line">最后的最后，交给大家一个绝招，一个终极方案，那就是多练！多练！多练。</span><br><span class="line">因为针对编程语言，其实就是需要掌握它的一些基本语法，大家都是有其它语言编程基础的，在这学习Scala语言，其实主要就是掌握这门语言和其它语言的一些不同之处，只要把这些东西捋顺了，那上手也是很容易的。</span><br></pre></td></tr></table></figure><h2 id="Scala环境安装配置"><a href="#Scala环境安装配置" class="headerlink" title="Scala环境安装配置"></a>Scala环境安装配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下面我们就来具体学习使用一下Scala这门神奇的语言。</span><br><span class="line">在具体使用之前需要先安装scala的开发环境，就类似安装java环境一样</span><br><span class="line"></span><br><span class="line">注意：由于Scala是基于Java虚拟机的，所以使用 Scala 之前必须先安装 Java，Java我们已经安装过了。</span><br><span class="line">那在这里我们先到官网下载Scala安装包</span><br><span class="line">Scala现在有三个主要在使用的版本， 2.11，2.12，2.13</span><br><span class="line">目前的话2.12使用的比较多，所以我们就使用这个版本</span><br></pre></td></tr></table></figure><h2 id="Scala命令行"><a href="#Scala命令行" class="headerlink" title="Scala命令行"></a>Scala命令行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">咱们刚才进入的就是Scala命令行</span><br><span class="line">Scala命令行也称为Scala解释器(REPL)，它会快速编译Scala代码为字节码，然后交给JVM来执行</span><br><span class="line">这里的REPL表示：Read（取值）-&gt; Evaluation（求值）-&gt; Print（打印）-&gt; Loop（循环）</span><br><span class="line">在Scala命令行内，输入Scala代码，解释器会直接返回结果</span><br><span class="line">如果你没有指定变量来存放计算的值，那么值默认的名称会显示为res开头的变量，而且会显示结果的数据类型</span><br><span class="line">scala&gt; 1+1</span><br><span class="line">res0: Int &#x3D; 2</span><br><span class="line">在后面可以继续使用res0这个变量，以及它里面存放的值</span><br><span class="line">scala&gt; 5 * res0</span><br><span class="line">res1: Int &#x3D; 10</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala的命令行也有自动补全功能，使用起来还是比较方便的</span><br><span class="line">输入res，按键盘上的tab键，下面就会列出目前以res开头的变量名称</span><br><span class="line">scala&gt; res</span><br><span class="line">res0 res1</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Scala" scheme="http://tianyong.fun/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>maven相关</title>
    <link href="http://tianyong.fun/maven%E7%9B%B8%E5%85%B3.html"/>
    <id>http://tianyong.fun/maven%E7%9B%B8%E5%85%B3.html</id>
    <published>2022-02-21T15:35:12.000Z</published>
    <updated>2022-02-21T15:57:06.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="maven相关"><a href="#maven相关" class="headerlink" title="maven相关"></a>maven相关</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.打jar包</span><br><span class="line">在项目根目录下</span><br><span class="line">mvn clean package -DskipTests</span><br><span class="line"></span><br><span class="line">2.为项目下载pom上配置的依赖</span><br><span class="line">在项目根目录下(用cmd或IDEA)</span><br><span class="line">mvn clean compile</span><br><span class="line"></span><br><span class="line">下载后，在项目上右键-&gt;maven-&gt;reload project</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="maven" scheme="http://tianyong.fun/categories/maven/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql安装</title>
    <link href="http://tianyong.fun/mysql%E5%AE%89%E8%A3%85.html"/>
    <id>http://tianyong.fun/mysql%E5%AE%89%E8%A3%85.html</id>
    <published>2022-02-20T10:02:24.000Z</published>
    <updated>2022-02-20T14:59:21.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h1><p><a href="https://www.cnblogs.com/ivy-zheng/p/11088644.html" target="_blank" rel="external nofollow noopener noreferrer">url1</a></p><p><a href="https://blog.csdn.net/t15263857960/article/details/83590484" target="_blank" rel="external nofollow noopener noreferrer">url2</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.安装包是目免安装型的</span><br><span class="line">2.在系统环境变量里添加mysql的路径到xxx\bin(也可以用管理员权限打开的cmd，切到这个路径下，再执行命令)</span><br><span class="line">3.用管理员权限打开cmd，输入</span><br><span class="line">mysqld --initialize --console  (注意一定要看之前是否安装过mysql,在环境变量里，一眼就可以看出，不然总是报各种错误; 加上console可以看到初始化后为root创建的临时密码)</span><br><span class="line">4.mysqld -install 将mysql服务安装到win服务</span><br><span class="line">5.net start mysql (启动服务)</span><br><span class="line">6.mysql -uroot -p 再输入之前生成的临时密码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果安装时已有mysql服务，删除：sc delete mysql</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/b70a2cb5d4be" target="_blank" rel="external nofollow noopener noreferrer">url</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改临时密码</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; &#x2F;&#x2F;记得修改自己的账户</span><br><span class="line">flush privileges; &#x2F;&#x2F;修改成功后刷新权限</span><br><span class="line">quit; &#x2F;&#x2F;最后退出</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第八周 第6章 Hive技巧与核心复盘</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%85%AB%E5%91%A8-%E7%AC%AC6%E7%AB%A0-Hive%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%A4%8D%E7%9B%98.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E5%85%AB%E5%91%A8-%E7%AC%AC6%E7%AB%A0-Hive%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%A4%8D%E7%9B%98.html</id>
    <published>2022-02-20T04:02:41.000Z</published>
    <updated>2022-02-21T08:37:46.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hive" scheme="http://tianyong.fun/tags/Hive/"/>
    
  </entry>
  
</feed>
