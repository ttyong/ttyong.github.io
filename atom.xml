<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TianYong&#39;s Blog</title>
  
  <subtitle>比你优秀的人都努力，有什么理由不努力！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tianyong.fun/"/>
  <updated>2022-01-13T14:39:09.128Z</updated>
  <id>http://tianyong.fun/</id>
  
  <author>
    <name>TTYONG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始学大数据-04讲移动计算比移动数据更划算</title>
    <link href="http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-04%E8%AE%B2%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%AF%94%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%88%92%E7%AE%97.html"/>
    <id>http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-04%E8%AE%B2%E7%A7%BB%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%AF%94%E7%A7%BB%E5%8A%A8%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%88%92%E7%AE%97.html</id>
    <published>2022-01-13T13:39:25.000Z</published>
    <updated>2022-01-13T14:39:09.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="04讲移动计算比移动数据更划算"><a href="#04讲移动计算比移动数据更划算" class="headerlink" title="04讲移动计算比移动数据更划算"></a>04讲移动计算比移动数据更划算</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大数据技术和传统的软件开发技术在架构思路上有很大不同，大数据技术更为关注数据，所以相关的架构设计也围绕数据展开，如何存储、计算、传输大规模的数据是要考虑的核心要素。</span><br><span class="line">传统的软件计算处理模型，都是“输入 -&gt; 计算 -&gt; 输出”模型。也就是说，一个程序给它传入一些数据也好，它自己从某个地方读取一些数据也好，总是先有一些输入数据，然后对这些数据进行计算处理，最后得到输出结果。</span><br><span class="line">但是在互联网大数据时代，需要计算处理的数据量急速膨胀。一来是因为互联网用户数远远超过传统企业的用户，相应产生了更大量的数据；二来很多以往被忽视的数据重新被发掘利用，比如用户在一个页面的停留时长、鼠标在屏幕移动的轨迹都会被记录下来进行分析。在稍微大一点的互联网企业，需要计算处理的数据量常常以PB计（10^15 Byte）。</span><br><span class="line">正因为如此，传统的计算处理模型不能适用于大数据时代的计算要求。你能想象一个程序读取PB级的数据进行计算是怎样一个场景吗？一个程序所能调度的网络带宽（通常数百MB）、内存容量（通常几十GB ）、磁盘大小（通常数TB）、CPU运算速度是不可能满足这种计算要求的。</span><br></pre></td></tr></table></figure><h2 id="那么如何解决PB级数据进行计算的问题呢？"><a href="#那么如何解决PB级数据进行计算的问题呢？" class="headerlink" title="那么如何解决PB级数据进行计算的问题呢？"></a>那么如何解决PB级数据进行计算的问题呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个问题的解决思路其实跟大型网站的分布式架构思路是一样的，采用分布式集群的解决方案，用数千台甚至上万台计算机构建一个大数据计算处理集群，利用更多的网络带宽、内存空间、磁盘容量、CPU核心数去进行计算处理。关于分布式架构，你可以参考我写的《大型网站技术架构：核心原理与案例分析》这本书，但是大数据计算处理的场景跟网站的实时请求处理场景又有很大不同。</span><br><span class="line">网站实时处理通常针对单个用户的请求操作，虽然大型网站面临大量的高并发请求，比如天猫的“双十一”活动。但是每个用户之间的请求是独立的，只要网站的分布式系统能将不同用户的不同业务请求分配到不同的服务器上，只要这些分布式的服务器之间耦合关系(事物之间存在的相互作用、相互影响的关系)足够小，就可以通过添加更多的服务器去处理更多的用户请求及由此产生的用户数据。这也正是网站系统架构的核心原理。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大数据计算处理通常针对的是网站的存量数据，也就是刚才我提到的全部用户在一段时间内请求产生的数据，这些数据之间是有大量关联的，比如购买同一个商品用户之间的关系，这是使用协同过滤进行商品推荐；比如同一件商品的历史销量走势，这是对历史数据进行统计分析。网站大数据系统要做的就是将这些统计规律和关联关系计算出来，并由此进一步改善网站的用户体验和运营决策。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为了解决这种计算场景的问题，技术专家们设计了一套相应的技术架构方案。最早的时候由Google实现并通过论文的方式发表出来，随后根据这些论文，开源社区开发出对应的开源产品，并得到业界的普遍支持和应用。</span><br><span class="line">这套方案的核心思路是，既然数据是庞大的，而程序要比数据小得多，将数据输入给程序是不划算的，那么就反其道而行之，将程序分发到数据所在的地方进行计算，也就是所谓的移动计算比移动数据更划算。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有一句古老的谚语，说的是“当一匹马拉不动车的时候，用两匹马拉”。听起来是如此简单的道理，但是在计算机这个最年轻的科技领域，在很长一段时间里却并没有这样做。当一台计算机的处理能力不能满足计算要求的时候，我们并没有想办法用两台计算机去处理，而是换更强大的计算机。商业级的服务器不够用，就升级小型机；小型机不够用，就升级中型机；还不够，升级大型机，升级超级计算机。</span><br><span class="line">在互联网时代之前，这种不断升级计算机硬件的办法还是行得通的，凭借摩尔定律，计算机硬件的处理能力每18个月增强一倍，越来越强大的计算机被制造出来。传统企业虽然对计算机的处理需求越来越高，但是工程师和科学家总能制造出满足需求的计算机。</span><br><span class="line">但是这种思路并不适合互联网的技术要求。Google、Facebook、阿里巴巴这些网站每天需要处理数十亿次的用户请求、产生上百PB的数据，不可能有一台计算机能够支撑起这么大的计算需求。</span><br><span class="line">于是互联网公司不得不换一种思路解决问题，当一台计算机的计算能力不能满足需求的时候，就增加一台计算机，还不够的话，就再增加一台。就这样，由一台计算机起家的小网站，逐渐成长为百万台服务器的巨无霸。Google、Facebook、阿里巴巴这些公司的成长过程都是如此。</span><br><span class="line">但是买一台新计算机和一台老计算机放在一起，就能自己开始工作了吗？两台计算机要想合作构成一个系统，必须要在技术上重新架构。这就是现在互联网企业广泛使用的负载均衡、分布式缓存、分布式数据库、分布式服务等种种分布式系统。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当这些分布式技术满足互联网的日常业务需求时，对离线数据和存量数据的处理就被提了出来，当时这些分布式技术并不能满足要求，于是大数据技术就出现了。</span><br></pre></td></tr></table></figure><h2 id="现在我们来看，移动计算程序到数据所在位置进行计算是如何实现的呢？"><a href="#现在我们来看，移动计算程序到数据所在位置进行计算是如何实现的呢？" class="headerlink" title="现在我们来看，移动计算程序到数据所在位置进行计算是如何实现的呢？"></a>现在我们来看，移动计算程序到数据所在位置进行计算是如何实现的呢？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1.将待处理的大规模数据存储在服务器集群的所有服务器上，主要使用HDFS分布式文件存储系统，将文件分成很多块（Block），以块为单位存储在集群的服务器上。</span><br><span class="line"> 2.大数据引擎根据集群里不同服务器的计算能力，在每台服务器上启动若干分布式任务执行进程，这些进程会等待给它们分配执行任务。</span><br><span class="line"> 3.使用大数据计算框架支持的编程模型进行编程，比如Hadoop的MapReduce编程模型，或者Spark的RDD编程模型。应用程序编写好以后，将其打包，MapReduce和Spark都是在JVM环境中运行，所以打包出来的是一个Java的JAR包。</span><br><span class="line"> 4.用Hadoop或者Spark的启动命令执行这个应用程序的JAR包，首先执行引擎会解析程序要处理的数据输入路径，根据输入数据量的大小，将数据分成若干片（Split），每一个数据片都分配给一个任务执行进程去处理。</span><br><span class="line"> 5.任务执行进程收到分配的任务后，检查自己是否有任务对应的程序包，如果没有就去下载程序包，下载以后通过反射的方式加载程序。走到这里，最重要的一步，也就是移动计算就完成了。</span><br><span class="line"> 6.加载程序后，任务执行进程根据分配的数据片的文件地址和数据在文件内的偏移量读取数据，并把数据输入给应用程序相应的方法去执行，从而实现在分布式服务器集群中移动计算程序，对大规模数据进行并行处理的计算目标。</span><br><span class="line"></span><br><span class="line">这只是大数据计算实现过程的简单描述，具体过程我们会在讲到HDFS、MapReduce和Spark的时候详细讨论。</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">移动程序到数据所在的地方去执行，这种技术方案其实我们并不陌生。从事Java开发的同学可能有过用反射的方式热加载代码执行的经验，如果这个代码是从网络其他地方传输过来的，那就是在移动计算。杀毒软件从服务器更新病毒库，然后在Windows内查杀病毒，也是一种移动计算（病毒库）比移动数据（Windows可能感染病毒的程序）更划算的例子。</span><br><span class="line">大数据技术将移动计算这一编程技巧上升到编程模型的高度，并开发了相应的编程框架，使得开发人员只需要关注大数据的算法实现，而不必关注如何将这个算法在分布式的环境中执行，这极大地简化了大数据的开发难度，并统一了大数据的开发方式，从而使大数据从原来的高高在上，变成了今天的人人参与。</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">互联网应用系统架构中有一种重要架构原则(分布式架构的原则)是尽量使用无状态的服务，不同服务实例之间不共享状态，也就是不持有数据，用户请求交给任何一个服务实例计算，处理的结果都是一样的，为什么要这样设计？这种架构有什么好处？</span><br><span class="line">1.这个应该是分布式架构的设计者在考虑架构的可扩展行（伸缩性）的时候设计出来的这样一个针对于服务的一个要求或者是标准（也就是原则）</span><br><span class="line">2.无状态服务的主要好处是服务间无需同步状态或者数据，便于扩缩容。</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="从零开始学大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始学大数据-03讲大数据应用领域：数据驱动一切</title>
    <link href="http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-03%E8%AE%B2%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%80%E5%88%87.html"/>
    <id>http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-03%E8%AE%B2%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%80%E5%88%87.html</id>
    <published>2022-01-13T10:12:08.000Z</published>
    <updated>2022-01-13T13:39:23.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="03讲大数据应用领域：数据驱动一切"><a href="#03讲大数据应用领域：数据驱动一切" class="headerlink" title="03讲大数据应用领域：数据驱动一切"></a>03讲大数据应用领域：数据驱动一切</h1><h2 id="大数据在医疗健康领域的应用"><a href="#大数据在医疗健康领域的应用" class="headerlink" title="大数据在医疗健康领域的应用"></a>大数据在医疗健康领域的应用</h2><h3 id="医学影像智能识别"><a href="#医学影像智能识别" class="headerlink" title="医学影像智能识别"></a>医学影像智能识别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图像识别是机器学习获得的重大突破之一，使用大量的图片数据进行深度机器学习训练，机器可以识别出特定的图像元素，比如猫或者人脸，当然也可以识别出病理特征。</span><br><span class="line">可以说医学影像智能识别在某些方面已经比一般医生拥有更高的读图和识别能力，但是鉴于医疗的严肃性，现在还很少有临床方面的实践。</span><br><span class="line">虽然在临床实践方面应用有限，但是医疗影像AI还是在一些领域取得一定的进展。医学影像智能识别，一方面可以帮助医生进行辅助诊疗，另一方面对于皮肤病等有外部表现的病症，病人可以自己拍照然后使用AI智能识别做一个初步诊断。</span><br></pre></td></tr></table></figure><h3 id="病历大数据智能诊疗"><a href="#病历大数据智能诊疗" class="headerlink" title="病历大数据智能诊疗"></a>病历大数据智能诊疗</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">病历，特别是专家写的病历，本身就是一笔巨大的知识财富，利用大数据技术将这些知识进行处理、分析、统计、 挖掘，可以构成一个病历知识库，可以分享给更多人，即构成一个智能辅助诊疗系统。</span><br></pre></td></tr></table></figure><h2 id="大数据在教育领域的应用"><a href="#大数据在教育领域的应用" class="headerlink" title="大数据在教育领域的应用"></a>大数据在教育领域的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">教育倡导“因人施教”，但是在传统教育过程中要做到因人施教，需要老师本身能力很强才能把握好。但是大数据在线教育利用大数据技术进行分析统计，完全可以做到根据学生能力和学习节奏，及时调整学习大纲和学习进度，提供个性化和自适应的学习体验。除此之外，人工智能在教育的其他方面也取得很好的进展。</span><br></pre></td></tr></table></figure><h3 id="AI外语老师"><a href="#AI外语老师" class="headerlink" title="AI外语老师"></a>AI外语老师</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">得益于语音识别和语音合成技术的成熟（语音识别与合成技术同样是利用大数据技术进行机器学习与训练），一些在线教育网站尝试用人工智能外语老师进行外语教学。这里面的原理其实并不复杂，聊天机器人技术已经普遍应用，只要将学习的知识点设计进聊天的过程中，就可以实现一个简单的AI外语老师了。</span><br></pre></td></tr></table></figure><h3 id="智能解题"><a href="#智能解题" class="headerlink" title="智能解题"></a>智能解题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比较简单的智能解题系统其实是利用搜索引擎技术，在收集大量的试题以及答案的基础上，进行试题匹配，将匹配成功的答案返回。这个过程看起来就像智能做题一样，表面看给个题目就能解出答案，而实际上只是找到答案。</span><br><span class="line">进阶一点的智能解题系统，通过图像识别与自然语言处理（这两项技术依然使用大数据技术实现），进行相似性匹配。更改试题的部分数字、文字表述，但是不影响实质性解答思路，依然可以解答。</span><br><span class="line">高阶的智能解题系统，利用神经网络机器学习技术，将试题的自然语言描述转化成形式语言，然后分析知识点和解题策略，进行自动推导，从而完成实质性的解题。</span><br></pre></td></tr></table></figure><h2 id="大数据在社交媒体领域的应用"><a href="#大数据在社交媒体领域的应用" class="headerlink" title="大数据在社交媒体领域的应用"></a>大数据在社交媒体领域的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大数据有一个重要的、和我们大多数人密切相关，但是又不太引人注目的一个应用领域是舆情监控与分析。我们日常在各种互联网应用和社交媒体上发表各种言论，这些言论事实上反映了最准确的民情舆论。一个个体的言论基本没有意义，但是大量的、全国乃至全球的言论数据表现出的统计特性，就有了非常重要的意义。</span><br><span class="line">编写数据爬虫，实时爬取各个社交新媒体上的各种用户内容和媒体信息，然后通过自然语言处理，就可以进行情感分析、热点事件追踪等。舆情实时监控可用于商业领域，引导智能广告投放；可用于金融领域，辅助执行自动化股票、期权、数字货币交易；可用于社会管理，及时发现可能引发社会问题的舆论倾向。</span><br><span class="line">在美国总统大选期间，候选人就曾雇佣大数据公司利用社交媒体的数据进行分析，发现选票可能摇摆的地区，有针对性前去进行竞选演讲。并利用大数据分析选民关注的话题，包装自己的竞选主张。</span><br></pre></td></tr></table></figure><h2 id="大数据在金融领域的应用"><a href="#大数据在金融领域的应用" class="headerlink" title="大数据在金融领域的应用"></a>大数据在金融领域的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大数据在金融领域应用比较成熟的是大数据风控。在金融借贷中，如何识别出高风险用户，要求其提供更多抵押、支付更高利息、调整更低的额度，甚至拒绝贷款，从而降低金融机构的风险？事实上，金融行业已经沉淀了大量的历史数据，利用这些数据进行计算，可以得到用户特征和风险指数的曲线（即风控模型）。当新用户申请贷款的时候，将该用户特征带入曲线进行计算，就可以得到该用户的风险指数，进而自动给出该用户的贷款策略。</span><br><span class="line">利用股票、外汇等历史交易记录，分析交易规律，结合当前的新闻热点、舆论倾向、财经数据构建交易模型，进行自动化交易，这就是金融领域的量化交易。这些数据量特别巨大，交易涉及金额也同样巨大，所以金融机构在大数据领域常常不惜血本，大手笔投入。</span><br></pre></td></tr></table></figure><h2 id="大数据在新零售领域的应用"><a href="#大数据在新零售领域的应用" class="headerlink" title="大数据在新零售领域的应用"></a>大数据在新零售领域的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">区别于传统零售，新零售使用大数据进行全链路管理。从生产、物流、购物体验，使用大数据进行分析和预判，实现精准生产、零库存、全新的购物体验。</span><br><span class="line">亚马逊Go无人店使用大量的摄像头，实时捕捉用户行为，判断用户取出还是放回商品、取了何种商品等。这实际上是大数据流计算与机器学习的结合，最终实现的购物效果是，无需排队买单，进去就拿东西，拿好了就走，超级科幻有没有。</span><br><span class="line">虽然无人店现在看起来噱头的意味更多一点，但是利用大数据技术提升购物体验、节省商家人力成本一定是正确的方向。</span><br></pre></td></tr></table></figure><h2 id="大数据在交通领域的应用"><a href="#大数据在交通领域的应用" class="headerlink" title="大数据在交通领域的应用"></a>大数据在交通领域的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交通也是一个对大数据实时采集与处理应用比较广的领域。现在几乎所有的城市路段、交通要点都有不止一个监控摄像头在实时监控，一线城市大约有百万计的摄像头在不停地采集数据。这些数据一方面可以用于公共安全，比如近年来一些警匪片里会有一些场景：犯罪嫌疑人驾车出逃，警方只要定位了车辆，不管它到哪里，系统都可以自动调出相应的摄像头，实时看到现场画面。应该说这项技术已经成熟，大数据流计算可以对百万计的流数据实时处理计算，电影里的场景计算其实并不复杂。</span><br><span class="line">此外，各种导航软件也在不停采集数据，通过分析用户当前位置和移动速度，判断道路拥堵状态，并实时修改推荐的导航路径。</span><br><span class="line">还有就是无人驾驶技术，无人驾驶就是在人的驾驶过程中实时采集车辆周边数据和驾驶控制信息，然后通过机器学习，获得周边信息与驾驶方式的对应关系（自动驾驶模型）。然后将这个模型应用到无人驾驶汽车上，传感器获得车辆周边数据后，就可以通过自动驾驶模型计算出车辆控制信息（转向、刹车等）。计算自动驾驶模型需要大量的数据，所以我们看到，这些无人驾驶创业公司都在不断攀比自己的训练数据有几十万公里、几百万公里，因为训练数据的量意味着模型的完善程度。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用大数据和机器学习，发掘数据中的规律，进而对当前的事情做出预测和判断，使机器表现出智能的特性，正变得越来越普及。</span><br><span class="line">大数据主要来自企业自身所产生，还有一些数据来自互联网，通过网络爬虫可以获取；再有就是公共数据，比如气象数据等。所有这些数据汇聚在一起，计算其内在的关系，可以发现很多肉眼和思维无法得到的知识。然后进一步计算其内在的模型，可以使系统获得智能的特性。当系统具备智能的特性，可以使机器对当前的事情做出预测和判断，正如我今天和你聊的，大数据技术应用正变得越来越普及。</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="从零开始学大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始学大数据-02 大数据应用发展史: 从搜索引擎到人工智能</title>
    <link href="http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-02-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%8F%91%E5%B1%95%E5%8F%B2-%E4%BB%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%88%B0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"/>
    <id>http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-02-%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E5%8F%91%E5%B1%95%E5%8F%B2-%E4%BB%8E%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%88%B0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html</id>
    <published>2022-01-12T14:51:09.000Z</published>
    <updated>2022-01-12T15:57:44.184Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="02-大数据应用发展史-从搜索引擎到人工智能"><a href="#02-大数据应用发展史-从搜索引擎到人工智能" class="headerlink" title="02 大数据应用发展史: 从搜索引擎到人工智能"></a>02 大数据应用发展史: 从搜索引擎到人工智能</h1><h2 id="大数据应用的搜索引擎时代"><a href="#大数据应用的搜索引擎时代" class="headerlink" title="大数据应用的搜索引擎时代"></a>大数据应用的搜索引擎时代</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Google公认的大数据鼻祖，存储着全世界大量的网页，大约需要数万块磁盘----&gt;GFS，将数千台服务器上的数万块磁盘统一管理起来，然后当作一个文件系统，统一存储所有这些网页文件。----&gt;构建搜索引擎，需要对这数万块磁盘上的文件中的单词进行词频统计，然后根据PageRank算法计算网页排名。这中间Google需要对磁盘上的文件进行计算处理----&gt;MapReduce大数据计算框架应运而生</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Google之前，世界闻名的搜索引擎是yahoo。Google凭借自己的大数据技术和pagerank算法，使搜索引擎体验得到质的飞跃，yahoo没落。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Doug cutting率先根据论文做了Hadoop。yahoo挖Doug Cutting----&gt;Doug Cutting跳槽到专职做Hadoop的商业化公司Cloudera.</span><br></pre></td></tr></table></figure><h2 id="大数据应用的数据仓库时代"><a href="#大数据应用的数据仓库时代" class="headerlink" title="大数据应用的数据仓库时代"></a>大数据应用的数据仓库时代</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当Facebook推出Hive的时候，嗅觉敏感的科技公司都不淡定了，他们开始意识到，大数据的时代真正开启了。</span><br><span class="line">曾经进行数据分析和统计，仅仅局限于数据库，在数据库的计算环境中对数据库中的数据表进行统计分析。受数据量和计算能力的限制，只能对最重要的数据进行统计和分析(这里所谓最重要的数据，通常指的都是给老板看的数据和财务相关的数据)。</span><br><span class="line">而HIve可以在Hadoop上进行SQL操作，实现数据统计和分析。可以用更低廉的价格获得比以往多更多的数据存储和计算能力。我们可以把运行日志、应用采集数据、数据库数据放到一起进行计算分析，获得以前无法得到的数据结果，企业的数据仓库也随之呈指数级膨胀。</span><br><span class="line">不仅是老板，公司中每个普通员工比如产品经理、运营人员、工程师，只要有数据访问权限，都可以提出分析需求，从大数据仓库中获得自己想要了解的数据分析结果。</span><br><span class="line">在数据仓库时代，只要有数据，几乎就一定要进行统计分析，如果数据规模比较大，我们就会想到要用Hadoop大数据技术，这也是Hadoop在这个时期发展特别快的一个原因。技术的发展同时又促进了技术应用，这也为接下来大数据应用走进数据挖掘时代埋下伏笔。</span><br></pre></td></tr></table></figure><h2 id="大数据应用的数据挖掘时代"><a href="#大数据应用的数据挖掘时代" class="headerlink" title="大数据应用的数据挖掘时代"></a>大数据应用的数据挖掘时代</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大数据一旦进入更多的企业，我们就会对大数据提出更多期望，除了数据统计，我们还希望发掘出更多数据的价值，大数据随之进入数据挖掘时代</span><br><span class="line">真实的案例，很早以前商家就通过数据发现，买尿不湿的人通常也会买啤酒，于是精明的商家就把这两样商品放在一起，以促进销售。啤酒和尿不湿的关系，你可以有各种解读，但是如果不是通过数据挖掘，可能打破脑袋也想不出它们之间会有关系。在商业环境中，如何解读这种关系并不重要，重要的是它们之间只要存在关联，就可以进行关联分析，最终目的是让用户尽可能看到想购买的商品。</span><br><span class="line">除了商品和商品有关系，还可以利用人和人之间的关系推荐商品。如果两个人购买的商品有很多都是类似甚至相同的，不管这两个人天南海北相隔多远，他们一定有某种关系，比如可能有差不多的教育背景、经济收入、兴趣爱好。根据这种关系，可以进行关联推荐，让他们看到自己感兴趣的商品。</span><br><span class="line">更进一步，大数据还可以将每个人身上的不同特性挖掘出来，打上各种各样的标签：90后、生活在一线城市、月收入1～2万、宅……这些标签组成了用户画像，并且只要这样的标签足够多，就可以完整描绘出一个人，甚至比你最亲近的人对你的描述还要完整、准确。</span><br><span class="line">除了商品销售，数据挖掘还可以用于人际关系挖掘。你听过“六度分隔理论”吗，它认为世界上两个互不认识的人，只需要很少的中间人就能把他们联系起来。这个理论在美国的实验结果是，通过六步就能联系上两个不认识的美国人。也是基于这个理论，Facebook研究了十几亿用户的数据，试图找到关联两个陌生人之间的数字，答案是惊人的3.57。你可以看到，各种各样的社交软件记录着我们的好友关系，通过关系图谱挖掘，几乎可以把世界上所有的人际关系网都描绘出来。</span><br></pre></td></tr></table></figure><h2 id="大数据应用的机器学习时代"><a href="#大数据应用的机器学习时代" class="headerlink" title="大数据应用的机器学习时代"></a>大数据应用的机器学习时代</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们很早就发现，数据中蕴藏着规律，这个规律是所有数据都遵循的，过去发生的事情遵循这个规律，将来要发生的事情也遵循这个规律。一旦找到了这个规律，对于正在发生的事情，就可以按照这个规律进行预测。</span><br><span class="line">在过去，我们受数据采集、存储、计算能力的限制，只能通过抽样的方式获取小部分数据，无法得到完整的、全局的、细节的规律。而现在有了大数据，可以把全部的历史数据都收集起来，统计其规律，进而预测正在发生的事情。-----这就是机器学习。</span><br><span class="line">把历史上人类围棋对弈的棋谱数据都存储起来，针对每一种盘面记录如何落子可以得到更高的赢面。得到这个统计规律以后，就可以利用这个规律用机器和人下棋，每一步都计算落在何处将得到更大的赢面，于是我们就得到了一个会下棋的机器人，这就是前两年轰动一时的AlphaGo，以压倒性优势下赢了人类的顶尖棋手。</span><br><span class="line">把人聊天的对话数据都收集起来，记录每一次对话的上下文，如果上一句是问今天过得怎么样，那么下一句该如何应对，通过机器学习可以统计出来。将来有人再问今天过得怎么样，就可以自动回复下一句话，于是我们就得到一个会聊天的机器人。Siri、天猫精灵、小爱同学，这样的语音聊天机器人在机器学习时代已经满大街都是了。</span><br><span class="line">将人类活动产生的数据，通过机器学习得到统计规律，进而可以模拟人的行为，使机器表现出人类特有的智能，这就是人工智能AI。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大数据从搜索引擎到机器学习，发展思路其实是一脉相承的，就是想发现数据中的规律并为我们所用。所以很多人把数据称作金矿，大数据应用就是从这座蕴含知识宝藏的金矿中发掘中有商业价值的真金白银出来。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据中蕴藏着价值已经是众所周知的事情了，那么如何从这些庞大的数据中发掘出我们想要的知识价值，这正是大数据技术目前正在解决的事情，包括大数据存储与计算，也包括大数据分析、挖掘、机器学习等应用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们不曾生活在美国西部淘金的繁荣时代，错过了那个光荣与梦想、自由与激情的个人英雄主义时代。但是现在，一个更具划时代意义的大数据淘金时代已经到来，而你我正身处其中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">统计人的驾驶行为进行机器学习，就是无人驾驶；统计股票的历史交易数据进行机器学习，就得到量化交易系统。统计大家p图的参数进行智能美颜。统计过去在网上的商品浏览进行机器学习，就有了亚马逊的智能推荐物品；蚂蚁金服上统计过去的消费能力和信贷进行机器学习，来预测可在借呗上借多少钱，这是一个大数据和机器智能的时代，我们身处其中，需要的是适应并不断学习前行才不会在一段接一段的浪潮中被退去。推荐系统、广告系统、估价系统、风控系统都是现在广泛使用了机器学习的。微软识花</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="从零开始学大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>从零开始学大数据-01 大数据的前世今生</title>
    <link href="http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-01-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html"/>
    <id>http://tianyong.fun/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE-01-%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F.html</id>
    <published>2022-01-12T07:23:40.000Z</published>
    <updated>2022-01-12T15:03:43.043Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="大数据的前世今生"><a href="#大数据的前世今生" class="headerlink" title="大数据的前世今生"></a>大数据的前世今生</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大多数公司还专注于提升单机性能，寻找更贵更好的服务器，google的思路是部署一个大规模服务器集群，通过分布式的方式将海量数据存储在这个集群上，然后利用集群上所有服务器进行数据计算。这样不需要昂贵的服务器，却可以更好实现目的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lucene:全文检索引擎工具包</span><br><span class="line">nutch:开源搜索引擎</span><br><span class="line">Doug Cutting:lucene的创始人，nutch的开发者，hadoop之父</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2004前后google三篇论文(三驾马车: 分布式文件系统GFS、大数据分布式计算框架MapReduce和NoSQL数据库系统BigTable)——————&gt;doug cutting实现了类似GFS和mapreduce的功能————————&gt;2006年 doug cutting将nutch的大数据相关功能分离，形成独立的项目专门维护大数据技术也就是hadoop,主要包括hadoop分布式文件系统hdfs,大数据计算引擎mapreduce。------&gt;yahoo,baidu,alibaba使用Hadoop进行大数据存储和计算-----&gt;2008年Hadoop正式成为Apache的顶级项目。同年专门运营Hadoop的商业公司Cloudera成立。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hadoop纯用java编写的软件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yahoo开发pig脚本语言(由于使用mapreduce进行大数据编程太麻烦)，类似于sql语法，开发者可以使用pig脚本描述要对大数据集上进行的操作，pig进行编译后会生成mapreduce程序，然后在hadoop上运行。缺点:虽然比直接mapredue编程容易，但需学习新的脚本语法。-----&gt;facebook发布Hive,支持sql语法来进行大数据计算，hive会将sql语句转换成mapreduce程序。这样熟悉数据库的数据分析师和工程师便可以无门槛的进行大数据分析和处理了。极大的降低了hadoop的使用难度。----&gt;随后众多hadoop的周边产品开始出现，大数据生态体系开始形成(包括sqoop:专门将关系数据库中的数据导入导出到hadoop平台; Flume:聚合和传输; Oozie:MapReduce工作流调度引擎)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在hadoop早期，mapreduce既是执行引擎，又是资源调度框架，服务器集群的资源调度由MapReduce自己完成。但这样不利于资源复用，也使得mapreduce非常的臃肿。yarn应运而生，将mapreduce资源调度和执行引擎分离开来。2012年，yarn成为一个独立项目开始运营，随后被各大大数据产品支持，成为大数据平台上最主流的资源调度系统。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于MapReduce进行机器学习计算时性能非常差因为机器学习算法通常需要很多次迭代计算，而mapreduce每执行一次map和reduce计算都需要重新启动一次作业，带来了大量的无谓消耗。还有一点就是mapreduce使用磁盘作为存储介质，而2012年，内存已经突破容量和成本限制，成为数据运行过程中的主要存储介质。spark一经推出，立即受到业界的追捧，并逐步替代MapReduce在企业应用中的地位。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">批处理计算：像mapreduce，spark这类计算框架处理的业务场景，因为它们通常针对以&#39;天&#39;为单位产生的数据进行一次计算，得到所需的结果，这中间计算需要花费的时间大概是几十分钟或更长的时间。</span><br><span class="line">大数据离线计算：计算的数据是非在线得到的实时数据，而是历史数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在典型的大数据业务场景下，数据业务最通常的做法是，采用批处理的技术处理历史全量数据，采用流式计算处理实时新增数据。flink计算引擎，同时支持流式计算和批处理计算。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoSql系统处理的也是大规模海量数据的存储和访问，所以也被归为大数据技术。曾在2011年左右非常火爆，涌现了Hbase,Cassandra等许多优秀的产品。其中Hbase是从Hadoop中分离出来的，基于HDFS的NoSql系统。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大数据处理的主要应用场景包括数据分析，数据挖掘，机器学习。</span><br><span class="line">大数据分析：主要用hive,spark sql等sql引擎来完成</span><br><span class="line">数据挖掘和机器学习：有专门的机器学习框架TensorFlow,Mahout以及MLlib等，内置了主要的机器学习和数据挖掘算法。</span><br></pre></td></tr></table></figure><p><a href="https://imgtu.com/i/7uqqHK" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s4.ax1x.com/2022/01/12/7uqqHK.jpg" alt="7uqqHK.jpg"></a></p><hr><blockquote><p>在历史前进逻辑中前进，在时代发展的潮流中发展。</p><p>在风口中飞翔。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="从零开始学大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://tianyong.fun/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>python-基础操作</title>
    <link href="http://tianyong.fun/python-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html"/>
    <id>http://tianyong.fun/python-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-12-31T02:42:47.000Z</published>
    <updated>2021-12-31T02:42:47.947Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>pandas-基础操作</title>
    <link href="http://tianyong.fun/pandas-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html"/>
    <id>http://tianyong.fun/pandas-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html</id>
    <published>2021-05-27T06:29:21.000Z</published>
    <updated>2021-05-27T08:06:53.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="DataFrame基础操作"><a href="#DataFrame基础操作" class="headerlink" title="DataFrame基础操作"></a>DataFrame基础操作</h1><h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>],columns=[<span class="string">'a'</span>])</span><br></pre></td></tr></table></figure><h3 id="多维列表"><a href="#多维列表" class="headerlink" title="多维列表"></a>多维列表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">2</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>],[<span class="number">8</span>,<span class="number">8</span>,<span class="literal">None</span>]])</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2=pd.DataFrame(&#123;<span class="string">'b'</span>:[<span class="number">4</span>,<span class="number">7</span>,<span class="number">-3</span>,<span class="number">2</span>],<span class="string">'a'</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]&#125;)</span><br></pre></td></tr></table></figure><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df4=pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>),index=[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],columns=[<span class="string">'oh'</span>,<span class="string">'te'</span>,<span class="string">'ca'</span>])</span><br></pre></td></tr></table></figure><h2 id="排序DataFrame"><a href="#排序DataFrame" class="headerlink" title="排序DataFrame"></a>排序DataFrame</h2><h3 id="sort-index"><a href="#sort-index" class="headerlink" title="sort_index()"></a>sort_index()</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],index=[<span class="number">10</span>,<span class="number">52</span>,<span class="number">24</span>,<span class="number">158</span>,<span class="number">112</span>],columns=[<span class="string">'s'</span>])</span><br><span class="line">df1.sort_index()</span><br></pre></td></tr></table></figure><h3 id="sort-values"><a href="#sort-values" class="headerlink" title="sort_values()"></a>sort_values()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2&#x3D;pd.DataFrame(&#123;&#39;b&#39;:[4,7,-3,2],&#39;a&#39;:[0,1,0,1]&#125;)</span><br><span class="line">df2.sort_values(by&#x3D;&#39;b&#39;)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="drop"><a href="#drop" class="headerlink" title="drop()"></a>drop()</h3><h4 id="删除行"><a href="#删除行" class="headerlink" title="删除行"></a>删除行</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df4=pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>),index=[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],columns=[<span class="string">'oh'</span>,<span class="string">'te'</span>,<span class="string">'ca'</span>])</span><br><span class="line">df4.drop(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df4=pd.DataFrame(np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>),index=[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],columns=[<span class="string">'oh'</span>,<span class="string">'te'</span>,<span class="string">'ca'</span>])</span><br><span class="line">df4.drop([<span class="string">'oh'</span>],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="删除None值"><a href="#删除None值" class="headerlink" title="删除None值"></a>删除None值</h3><h4 id="dropna"><a href="#dropna" class="headerlink" title="dropna()"></a>dropna()</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">2</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>],[<span class="number">8</span>,<span class="number">8</span>,<span class="literal">None</span>]])</span><br><span class="line"> df1.dropna()</span><br></pre></td></tr></table></figure><h4 id="dropna-how-’all’"><a href="#dropna-how-’all’" class="headerlink" title="dropna(how=’all’)"></a>dropna(how=’all’)</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1=pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">2</span>],[<span class="literal">None</span>,<span class="literal">None</span>,<span class="literal">None</span>],[<span class="number">8</span>,<span class="number">8</span>,<span class="literal">None</span>]])</span><br><span class="line">df1.dropna(how=<span class="string">'all'</span>)</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>python廖雪峰-基础</title>
    <link href="http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E5%9F%BA%E7%A1%80.html"/>
    <id>http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E5%9F%BA%E7%A1%80.html</id>
    <published>2021-04-15T06:40:29.000Z</published>
    <updated>2021-04-15T07:21:46.385Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h2 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h2><h3 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><em>Python可以处理任意大小的整数，当然包括负整数</em></p><p><em>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用<code>0x</code>前缀和0-9，a-f表示，例如：<code>0xff00</code>，<code>0xa5b4c3d2</code>，等等</em></p><p><em>对于很大的数，例如<code>10000000000</code>，很难数清楚0的个数。Python允许在数字中间以<code>_</code>分隔，因此，写成<code>10_000_000_000</code>和<code>10000000000</code>是完全一样的。十六进制数也可以写成<code>0xa1b2_c3d4</code></em></p><h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><p><em>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）</em></p><p><em>之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，<code>1.23x10**9</code>和<code>12.3x10**8</code>是完全相等的</em></p><p><em>但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是<code>1.23e9</code>，或者<code>12.3e8</code>，0.000012可以写成<code>1.2e-5</code>，等等</em></p><p><em>整数和浮点数在计算机内部存储的方式是不同的，<strong>整数运算永远是精确的</strong>（除法难道也是精确的？是的！），而<strong>浮点数运算</strong>则可能会有<strong>四舍五入的</strong>误差</em></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p><em>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本</em></p><p><em>如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符</em></p><p><em>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'I\'m \"OK\"!'</span> <span class="comment"># I'm "OK"!</span></span><br></pre></td></tr></table></figure><p><em>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'\\\t\\'</span>)</span><br><span class="line">\       \</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'\\\t\\'</span>)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><p><em>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'''line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3'''</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><h5 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h5><h5 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h5><p><em>None</em></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><em>可以将一个类型的变量赋值为另一种类型</em></p><p><em>这种变量本身类型不固定的语言称之为<strong>动态语言</strong>，与之对应的是<strong>静态语言</strong>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。</em></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p><em>常量就是不能变的变量</em></p><p><em>在Python中，通常用全部大写的变量名表示常量</em></p><h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p><em>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理</em></p><p><em>最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码</em></p><p><em>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去</em></p><p><em>各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</em></p><p><strong>Unicode</strong>把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p><strong>ASCII编码和Unicode编码的区别</strong>：<em>ASCII编码是1个字节，而Unicode编码通常是2个字节</em></p><p><em>如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code></em></p><p><em>新<strong>的问题又出现了</strong>：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算</em></p><p><em>本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码，<strong>UTF-8编码</strong>把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间</em></p><p><em>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</em></p><p><em>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</em></p><p><em>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器</em></p><h4 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h4><p><em>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言</em></p><p><strong>对于单个字符的编码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(ord(<span class="string">'a'</span>)) <span class="comment"># 97</span></span><br><span class="line">print(chr(<span class="number">66</span>))  <span class="comment"># 'B'</span></span><br></pre></td></tr></table></figure><p><strong>知道字符的整数编码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'\u4e2d\u6587'</span></span><br><span class="line"><span class="comment"># 中文</span></span><br></pre></td></tr></table></figure><h5 id="str-replace-‘x’-‘b’"><a href="#str-replace-‘x’-‘b’" class="headerlink" title="str.replace(‘x’, ‘b’)"></a>str.replace(‘x’, ‘b’)</h5><h4 id="x-encode-and-b’xx’-decode"><a href="#x-encode-and-b’xx’-decode" class="headerlink" title="x.encode() and b’xx’.decode()"></a>x.encode() and b’xx’.decode()</h4><h5 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h5><p><em>一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code></em></p><p><em>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure><p><strong>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>) <span class="comment"># b'ABC'</span></span><br><span class="line"><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>) <span class="comment"># b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="comment"># 含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错</span></span><br></pre></td></tr></table></figure><h5 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'中文'</span></span><br></pre></td></tr></table></figure><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h4><p><em><code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc %s'</span>%<span class="string">'dhkhs'</span></span><br><span class="line"><span class="string">'hdhi %s %d'</span>%(<span class="string">'kjkd'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%d</span><br><span class="line">%s  <span class="comment"># 不清楚就直接用它，%s永远起作用，它会把任何数据类型转换为字符串</span></span><br><span class="line">%f</span><br><span class="line">%x  十六进制整数</span><br></pre></td></tr></table></figure><p><strong>字符串里面的<code>%</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'a%%b'</span> <span class="comment"># a%b</span></span><br></pre></td></tr></table></figure><h5 id="format"><a href="#format" class="headerlink" title="format"></a>format</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'</span>.format(<span class="string">'小明'</span>, <span class="number">17.125</span>)</span><br><span class="line"><span class="string">'Hello, 小明, 成绩提升了 17.1%'</span></span><br></pre></td></tr></table></figure><h5 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h5><p><em>它和普通字符串不同之处在于，字符串如果包含<code>{xxx}</code>，就会以对应的变量替换</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = <span class="number">2.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="number">3.14</span> * r ** <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">f'The area of a circle with radius <span class="subst">&#123;r&#125;</span> is <span class="subst">&#123;s:<span class="number">.2</span>f&#125;</span>'</span>)</span><br><span class="line">The area of a circle <span class="keyword">with</span> radius <span class="number">2.5</span> <span class="keyword">is</span> <span class="number">19.62</span></span><br></pre></td></tr></table></figure><h3 id="tuple和list"><a href="#tuple和list" class="headerlink" title="tuple和list"></a>tuple和list</h3><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><em>list是一种有序的集合</em></p><h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">l.insert(<span class="number">1</span>, <span class="string">'x'</span>)</span><br></pre></td></tr></table></figure><h5 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l.pop() <span class="comment"># 删除末尾</span></span><br><span class="line">l.pop(i) <span class="comment"># 删除指定位置</span></span><br></pre></td></tr></table></figure><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p><em>有序列表叫元组，tuple一旦初始化就不能修改</em></p><p><em>但如果元组里的某元素是列表时，列表里的元素可以改变</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = ()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>) <span class="comment"># 定义一个元素的元组不能这样定义，解释器默认为是数学中的小空号，可以在后面加‘，’</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p><em>if-elif…..else只要某条件满足，后续的不再判断</em></p><p><em>if-if-if-else</em>:<em>每步都会判断，除了else</em></p><h3 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h3><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p><em>dict内部存放的顺序和key放入的顺序是没有关系的</em></p><p><em>dict的key必须是<strong>不可变对象</strong>.在Python中，字符串、整数等都是不可变的</em></p><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><h5 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line">d[<span class="string">'c'</span>] <span class="comment"># 会报错，避免报错用下面的方法</span></span><br><span class="line"><span class="string">'c'</span> <span class="keyword">in</span> d</span><br><span class="line">d.get(<span class="string">'c'</span>) <span class="comment"># 返回None</span></span><br><span class="line">d.get(<span class="string">'c'</span>, <span class="number">1</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.pop(<span class="string">'a'</span>) <span class="comment"># 值也会随之删除</span></span><br></pre></td></tr></table></figure><h5 id="dict和list比较"><a href="#dict和list比较" class="headerlink" title="dict和list比较"></a>dict和list比较</h5><p>1.查找和插入的速度极快，不会随着key的增加而变慢；</p><p>2.需要占用大量的内存，内存浪费多</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p><em>在set中，没有重复的key，无序</em></p><p><em>要创建一个set，需要提供一个list作为输入集合</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.remove(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="python" scheme="http://tianyong.fun/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>python廖雪峰-简介</title>
    <link href="http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E7%AE%80%E4%BB%8B.html"/>
    <id>http://tianyong.fun/python%E5%BB%96%E9%9B%AA%E5%B3%B0-%E7%AE%80%E4%BB%8B.html</id>
    <published>2021-04-15T01:54:31.000Z</published>
    <updated>2021-04-15T06:41:01.372Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="python廖雪峰"><a href="#python廖雪峰" class="headerlink" title="python廖雪峰"></a>python廖雪峰</h1><h2 id="python简介"><a href="#python简介" class="headerlink" title="python简介"></a>python简介</h2><p><em>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间</em></p><p><em>荷兰人</em></p><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cpython: 从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython ## 由C语言编写</span><br><span class="line">Ipython: 基于CPython之上的一个交互式解释器，也就是说，只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的</span><br><span class="line">PyPy: 是另一个Python解释器，它的目标是执行速度</span><br><span class="line">Jython: Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行</span><br><span class="line">IronPython: IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器</span><br></pre></td></tr></table></figure><h2 id="第一个python程序"><a href="#第一个python程序" class="headerlink" title="第一个python程序"></a>第一个python程序</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><p><em>可以接受多个字符串，用逗号隔开(逗号以空格呈现)，并一行输出</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'The quick brown fox'</span>, <span class="string">'jumps over'</span>, <span class="string">'the lazy dog'</span>)</span><br><span class="line"><span class="comment"># The quick brown fox jumps over the lazy dog</span></span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="python" scheme="http://tianyong.fun/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>jsDeliver+github打造属于自己的图床</title>
    <link href="http://tianyong.fun/jsDeliver-github%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A.html"/>
    <id>http://tianyong.fun/jsDeliver-github%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A.html</id>
    <published>2021-01-21T06:40:55.000Z</published>
    <updated>2021-01-21T06:55:17.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="jsDeliver-github打造属于自己的图床"><a href="#jsDeliver-github打造属于自己的图床" class="headerlink" title="jsDeliver+github打造属于自己的图床"></a>jsDeliver+github打造属于自己的图床</h1><h2 id="什么是图床"><a href="#什么是图床" class="headerlink" title="什么是图床"></a>什么是图床</h2><p><em>“图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。”<br>注意：<code>github 支持的就是cdn加速</code></em></p><h2 id="什么是jsDelive"><a href="#什么是jsDelive" class="headerlink" title="什么是jsDelive"></a>什么是jsDelive</h2><p><em>jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。</em></p><h2 id="jsDelive加载资源"><a href="#jsDelive加载资源" class="headerlink" title="jsDelive加载资源"></a>jsDelive加载资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;你的用户名&#x2F;你的仓库名@发布的版本号&#x2F;文件路径</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加载js</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;yremp&#x2F;cdn@1.0&#x2F;js&#x2F;jquery.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加载图片</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;yremp&#x2F;cdn@1.0&#x2F;images&#x2F;hb.png</span><br></pre></td></tr></table></figure><h2 id="现有的图床"><a href="#现有的图床" class="headerlink" title="现有的图床"></a>现有的图床</h2><h3 id="路过图床"><a href="#路过图床" class="headerlink" title="路过图床"></a>路过图床</h3><p><a href="https://imgchr.com/" target="_blank" rel="external nofollow noopener noreferrer">https://imgchr.com/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路过图床</span><br><span class="line">网站： https:&#x2F;&#x2F;imgchr.com&#x2F;</span><br><span class="line">简介：支持免注册上传图片，永久存储，支持HTTPS加密访 问和调用图片，提供多种图片链接格式，成立于2011年</span><br><span class="line">限制：最大10M</span><br></pre></td></tr></table></figure><h3 id="SM-MS"><a href="#SM-MS" class="headerlink" title="SM.MS"></a>SM.MS</h3><p><a href="https://sm.ms/" target="_blank" rel="external nofollow noopener noreferrer">https://sm.ms/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网站:https:&#x2F;&#x2F;sm.ms&#x2F;</span><br><span class="line">特点：永久存储免注册，图片链接支持https，可以删除上传 的图片，提供多种图片链接格式，建立于2015年，速度比路过图床慢</span><br><span class="line">图片上传限制：每个图片最大5M，每次最多上传10张</span><br></pre></td></tr></table></figure><h3 id="小贱贱图床"><a href="#小贱贱图床" class="headerlink" title="小贱贱图床"></a>小贱贱图床</h3><p><a href="http://pic.xiaojianjian.net" target="_blank" rel="external nofollow noopener noreferrer">http://pic.xiaojianjian.net</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">网站：http:&#x2F;&#x2F;pic.xiaojianjian.net</span><br><span class="line">需要注册，每日可以上传图片30张，上传后可以获取一个简单的外链，速度很快，但是图片清晰度会变低</span><br></pre></td></tr></table></figure><h3 id="聚合图床"><a href="#聚合图床" class="headerlink" title="聚合图床"></a>聚合图床</h3><p><a href="https://www.superbed.cn/" target="_blank" rel="external nofollow noopener noreferrer">https://www.superbed.cn</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网站：https:&#x2F;&#x2F;www.superbed.cn</span><br><span class="line">简介：将图片分发到多处备份，借助其本身的CDN加速功能，节省服务器流量，并且不用担心图片被删除，即便其中某几个图床上的图片被删除了，还有其他备份，保证万无一失，支持匿名和注册管理</span><br><span class="line">图片上传限制：无</span><br></pre></td></tr></table></figure><h3 id="堆爱外链"><a href="#堆爱外链" class="headerlink" title="堆爱外链"></a>堆爱外链</h3><p><a href="http://pan.duiai.cc/" target="_blank" rel="external nofollow noopener noreferrer">http://pan.duiai.cc</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">地址：http:&#x2F;&#x2F;pan.duiai.cc</span><br><span class="line">简介：注册才可以上传，存在的时间比较久，除了图片还可以上传视频和音乐</span><br><span class="line">限制：视频体积过大不可，但具体限制不明</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em>搭建图床的方法很多，就像<strong>七牛云</strong>30天后会回收测试域名，因此你必须要绑定自己的已经备案的域名，又拍云也需要绑定域名才可以使用，所有我不推荐大家使用。</em></p><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://tianyong.fun/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://tianyong.fun/tags/hexo/"/>
    
      <category term="图床" scheme="http://tianyong.fun/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>hexo-美化</title>
    <link href="http://tianyong.fun/hexo-%E7%BE%8E%E5%8C%96.html"/>
    <id>http://tianyong.fun/hexo-%E7%BE%8E%E5%8C%96.html</id>
    <published>2021-01-20T15:18:27.000Z</published>
    <updated>2021-01-20T15:27:25.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="hexo-美化"><a href="#hexo-美化" class="headerlink" title="hexo-美化"></a>hexo-美化</h1><h2 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h2><p><a href="https://www.zhihu.com/question/268140594" target="_blank" rel="external nofollow noopener noreferrer">透明度设置</a></p><h2 id="个性化回到首页"><a href="#个性化回到首页" class="headerlink" title="个性化回到首页"></a>个性化回到首页</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="external nofollow noopener noreferrer">个性化回到首页</a></p><h2 id="打字点击特效"><a href="#打字点击特效" class="headerlink" title="打字点击特效"></a>打字点击特效</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="external nofollow noopener noreferrer">打字点击特效</a></p><h2 id="卡通人物"><a href="#卡通人物" class="headerlink" title="卡通人物"></a>卡通人物</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="external nofollow noopener noreferrer">个性化回到首页</a></p><h2 id="随机彩带"><a href="#随机彩带" class="headerlink" title="随机彩带"></a>随机彩带</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="external nofollow noopener noreferrer">随机彩带</a></p><p><a href>动态彩带</a></p><h2 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="external nofollow noopener noreferrer">页面加载进度条</a></p><p>##</p><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大数据开发工程师-第一周</title>
    <link href="http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B8%80%E5%91%A8.html"/>
    <id>http://tianyong.fun/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88-%E7%AC%AC%E4%B8%80%E5%91%A8.html</id>
    <published>2021-01-20T05:58:10.000Z</published>
    <updated>2021-01-20T07:32:32.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><h2 id="群里问答"><a href="#群里问答" class="headerlink" title="群里问答"></a>群里问答</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即系查询框架哪个用的多?</span><br><span class="line">impala，Elasticsearch、Druid、Presto、ClickHouse等都可以</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你们写好的SparkStreaming测试是怎么测试?在本地测试还是扔到Yarn测试?</span><br><span class="line">一般是在测试环境里面测</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先IDEA 本地跑一下自测,然后放到测试环境的HDFS上 让yarn调度一下么?</span><br><span class="line">是的，在本地验证代码的正确性，在测试集群中验证代码业务流程层面的正确性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对实时计算所涉及的事务、容错性、可靠性有深入的理解</span><br><span class="line"></span><br><span class="line">这种问题，面试的时候  一般怎么回答？</span><br><span class="line">分析下一下实时计算中的几种语义级别，能讲清楚就差不多了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实时计算事务也应该是弱事务吧</span><br><span class="line">是的，大数据的高性能和事务其实是有点矛盾的</span><br><span class="line">事务很少问，容错性会问到，这个课程里面有讲到，就是那几种语义级别，至少一次，仅一次等</span><br></pre></td></tr></table></figure><h2 id="群里配置问答"><a href="#群里配置问答" class="headerlink" title="群里配置问答"></a>群里配置问答</h2><h3 id="flume"><a href="#flume" class="headerlink" title="flume"></a>flume</h3><p><a href="https://imgchr.com/i/sWu1zQ" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWu1zQ.md.jpg" alt="sWu1zQ.jpg" border="0"></a></p><p><em>解决：没有配置flume的日志，缺少log4j的配置，在flume的conf目录下</em></p><h2 id="虚拟机网络问题"><a href="#虚拟机网络问题" class="headerlink" title="虚拟机网络问题"></a>虚拟机网络问题</h2><h3 id="为什么我这样配置ping不同外网-本机也Ping不了？"><a href="#为什么我这样配置ping不同外网-本机也Ping不了？" class="headerlink" title="为什么我这样配置ping不同外网 本机也Ping不了？"></a>为什么我这样配置ping不同外网 本机也Ping不了？</h3><p><a href="https://imgchr.com/i/sWuXY8" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWuXY8.jpg" alt="sWuXY8.jpg" border="0"></a><br><a href="https://imgchr.com/i/sWuOFf" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWuOFf.md.jpg" alt="sWuOFf.md.jpg" border="0"></a><br><a href="https://imgchr.com/i/sWuqTP" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWuqTP.md.jpg" alt="sWuqTP.md.jpg" border="0"></a><br><a href="https://imgchr.com/i/sWujfS" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWujfS.md.jpg" alt="sWujfS.md.jpg" border="0"></a></p><p><em>解决：虚拟机防火墙需要关闭，虚拟机网卡为nat模式，配置后要重启</em></p><p><a href="https://imgchr.com/i/sWY4EQ" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/20/sWY4EQ.md.jpg" alt="sWY4EQ.jpg" border="0"></a></p><h3 id="vmnet8"><a href="#vmnet8" class="headerlink" title="vmnet8"></a>vmnet8</h3><p><em>我虚拟机和主机不在同一个网段 可能就靠这个vmnet8来做nat网络地址转换</em></p><p><em>解答：vmnet8是你的一块网卡，让你的虚拟机和你的物理机处于同一个网络，这样你的物理机和虚拟机可以互联互通，而你的虚拟机访问外网，就通过nat映射，使用你的物理机ip对外访问，NAT对应的还有PAT技术</em></p><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据开发工程师" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
    
  </entry>
  
  <entry>
    <title>第六章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-16T02:59:36.000Z</published>
    <updated>2021-01-16T03:22:18.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="构建数据仓库"><a href="#构建数据仓库" class="headerlink" title="构建数据仓库"></a>构建数据仓库</h1><p><strong>数组仓库的组成</strong>：维度表+事实表<br><strong>维度表</strong>：主要存放基础属性。<br><strong>事实表</strong>：主要存放各种业务数据</p><h2 id="构建维度表"><a href="#构建维度表" class="headerlink" title="构建维度表"></a>构建维度表</h2><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第五章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-16T02:43:31.000Z</published>
    <updated>2021-01-16T02:59:40.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="Kettle作业设计"><a href="#Kettle作业设计" class="headerlink" title="Kettle作业设计"></a>Kettle作业设计</h1><h2 id="作业的概念及组成"><a href="#作业的概念及组成" class="headerlink" title="作业的概念及组成"></a>作业的概念及组成</h2><p><em>一个作业包含一个或多个作业项，这些作业项以某种顺序来执行。作业执行顺序由作业项之间的跳和每个作业项的执行结果来决定。</em></p><p><strong>组成</strong>：作业项、作业跳(跳)、注释</p><h3 id="作业项"><a href="#作业项" class="headerlink" title="作业项"></a>作业项</h3><p><strong>与转换的步骤相比</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有影子复制</span><br><span class="line">作业项之间传递一个结果对象</span><br><span class="line">可以并行执行</span><br><span class="line">后缀名：转换（ktr),作业（kjb)</span><br></pre></td></tr></table></figure><h3 id="跳"><a href="#跳" class="headerlink" title="跳"></a>跳</h3><p><strong>三种判断方式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>两种状态</strong>：Enabled(可用)、Disabled(不可用)</p><h2 id="作业的创建及常用作业项"><a href="#作业的创建及常用作业项" class="headerlink" title="作业的创建及常用作业项"></a>作业的创建及常用作业项</h2><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p>回溯<br>多路径和回溯：作业运行的结果不是唯一的；<br>并行执行</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>定义</strong>：任意长度的字符串值，有自己的作用范围；<br><strong>定义变量的两种方式</strong>：系统设置和用户自定义；<br>系统设置：Java虚拟机、Kettle的内部变量；<br>用户自定义：使用kettle.properties文件。在“设置变量”中设置作业项的属性、获取属性文件中的变量</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p><strong>监控</strong>包括<strong>日志和邮件</strong>两种方式<br><em>日志包含的级别及其对应内容：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nothing:</span><br><span class="line">Error:</span><br><span class="line">Basic:</span><br><span class="line">Detailed:</span><br><span class="line">Debug:</span><br><span class="line">Rowlevel:</span><br><span class="line">Minimal:</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-16T02:16:00.000Z</published>
    <updated>2021-01-16T04:09:03.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第四章-数据清理"><a href="#第四章-数据清理" class="headerlink" title="第四章-数据清理"></a>第四章-数据清理</h1><h2 id="数据清理概述"><a href="#数据清理概述" class="headerlink" title="数据清理概述"></a>数据清理概述</h2><p><em>无论数据清理是在加载到数据仓库之前，还是在从数据仓库抽取数据时，都不可能跳过数据清理这个过程</em></p><h3 id="常用的数据清理步骤"><a href="#常用的数据清理步骤" class="headerlink" title="常用的数据清理步骤"></a>常用的数据清理步骤</h3><p><strong>kettle中几个常用数据清理步骤：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">计算器；</span><br><span class="line">字符串替换；</span><br><span class="line">字符串操作；</span><br><span class="line">字符串剪切：对字符串做剪切的功能；</span><br><span class="line">拆分字段；</span><br><span class="line">值映射；</span><br><span class="line">字段选择：可以对字段进行选择、删除、重命名等操作；</span><br><span class="line">去除重复记录和去除重复记录(哈希值)的两个步骤。</span><br></pre></td></tr></table></figure><h3 id="字符串清理"><a href="#字符串清理" class="headerlink" title="字符串清理"></a>字符串清理</h3><h3 id="字段清理"><a href="#字段清理" class="headerlink" title="字段清理"></a>字段清理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拆分字段成多行(列拆分为多行)：支持正则表达式；</span><br><span class="line">拆分字段；</span><br><span class="line">合并字段；</span><br><span class="line">字段选择： “选择和修改”、“移除”和“元数据”三个分类</span><br></pre></td></tr></table></figure><h4 id="列拆分为多行"><a href="#列拆分为多行" class="headerlink" title="列拆分为多行"></a>列拆分为多行</h4><p><a href="https://imgchr.com/i/sBjjIA" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/16/sBjjIA.png" alt="sBjjIA.png" border="0"></a></p><h4 id="拆分字段"><a href="#拆分字段" class="headerlink" title="拆分字段"></a>拆分字段</h4><img src="https://s3.ax1x.com/2021/01/16/sBvwLD.png" alt="sBvwLD.png" border="0"><h2 id="数据排重"><a href="#数据排重" class="headerlink" title="数据排重"></a>数据排重</h2><h3 id="如何识别重复数据"><a href="#如何识别重复数据" class="headerlink" title="如何识别重复数据"></a>如何识别重复数据</h3><p><em>数据是否指的同一客观实体</em></p><p><strong>重复数据分为两类：</strong>完全重复数据，不完全重复数据</p><p><strong>完全重复数据</strong>：两个数据行的数据完全一致</p><p><strong>不完全重复数据：</strong>客观上表示现实世界的同一实体，但由于表达方式不同或拼写错误等原因，导致数据存在多条重复</p><h3 id="去除完全重复数据"><a href="#去除完全重复数据" class="headerlink" title="去除完全重复数据"></a>去除完全重复数据</h3><h4 id="去除重复记录"><a href="#去除重复记录" class="headerlink" title="去除重复记录"></a>去除重复记录</h4><p><em>只能处理事先排好序的数据</em></p><h4 id="去除重复记录-哈希值"><a href="#去除重复记录-哈希值" class="headerlink" title="去除重复记录(哈希值)"></a>去除重复记录(哈希值)</h4><h3 id="去除不完全重复数据"><a href="#去除不完全重复数据" class="headerlink" title="去除不完全重复数据"></a>去除不完全重复数据</h3><h2 id="使用脚本组件进行数据清理"><a href="#使用脚本组件进行数据清理" class="headerlink" title="使用脚本组件进行数据清理"></a>使用脚本组件进行数据清理</h2><h3 id="使用JavaScript代码组件清理数据"><a href="#使用JavaScript代码组件清理数据" class="headerlink" title="使用JavaScript代码组件清理数据"></a>使用JavaScript代码组件清理数据</h3><h3 id="使用正则表达式组件清理数据"><a href="#使用正则表达式组件清理数据" class="headerlink" title="使用正则表达式组件清理数据"></a>使用正则表达式组件清理数据</h3><h3 id="使用其它脚本组件清理数据"><a href="#使用其它脚本组件清理数据" class="headerlink" title="使用其它脚本组件清理数据"></a>使用其它脚本组件清理数据</h3><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-15T03:07:45.000Z</published>
    <updated>2021-01-16T02:15:25.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第三章-基于kettle的数据导入与导出"><a href="#第三章-基于kettle的数据导入与导出" class="headerlink" title="第三章-基于kettle的数据导入与导出"></a>第三章-基于kettle的数据导入与导出</h1><h2 id="基于文件的数据导入与导出"><a href="#基于文件的数据导入与导出" class="headerlink" title="基于文件的数据导入与导出"></a>基于文件的数据导入与导出</h2><h3 id="文本文件的导入与导出"><a href="#文本文件的导入与导出" class="headerlink" title="文本文件的导入与导出"></a>文本文件的导入与导出</h3><p><strong>文本文件分类</strong>：分隔符文件；固定宽度文件</p><h3 id="文本文件的导入与导出案例"><a href="#文本文件的导入与导出案例" class="headerlink" title="文本文件的导入与导出案例"></a>文本文件的导入与导出案例</h3><h3 id="Excel文件的导入与导出"><a href="#Excel文件的导入与导出" class="headerlink" title="Excel文件的导入与导出"></a>Excel文件的导入与导出</h3><p><em>Excel文件：分为<strong>结构化的表格数据</strong>和<strong>非结构化的表格数据</strong>；对于非结构化表格数据，可能表里包含有多个字段值的列或者有重复的一组字段等</em></p><h3 id="Excel文件的导入与导出案例"><a href="#Excel文件的导入与导出案例" class="headerlink" title="Excel文件的导入与导出案例"></a>Excel文件的导入与导出案例</h3><h3 id="XML文件的导入与导出"><a href="#XML文件的导入与导出" class="headerlink" title="XML文件的导入与导出"></a>XML文件的导入与导出</h3><h3 id="XML文件的导入与导出案例"><a href="#XML文件的导入与导出案例" class="headerlink" title="XML文件的导入与导出案例"></a>XML文件的导入与导出案例</h3><h3 id="JSON文件的导入与导出"><a href="#JSON文件的导入与导出" class="headerlink" title="JSON文件的导入与导出"></a>JSON文件的导入与导出</h3><h3 id="JSON文件的导入与导出案例"><a href="#JSON文件的导入与导出案例" class="headerlink" title="JSON文件的导入与导出案例"></a>JSON文件的导入与导出案例</h3><h2 id="基于数据库的数据导入与导出"><a href="#基于数据库的数据导入与导出" class="headerlink" title="基于数据库的数据导入与导出"></a>基于数据库的数据导入与导出</h2><h3 id="关系型数据库的数据导入与导出"><a href="#关系型数据库的数据导入与导出" class="headerlink" title="关系型数据库的数据导入与导出"></a>关系型数据库的数据导入与导出</h3><p><em>面对关系型数据库，Kettle可以利用“表输入”、“表输出”步骤完成导入和导出</em></p><h3 id="MySQL数据库的数据导入与导出"><a href="#MySQL数据库的数据导入与导出" class="headerlink" title="MySQL数据库的数据导入与导出"></a>MySQL数据库的数据导入与导出</h3><p><em>“一般”选项卡常用的连接参数含义(主机名、数据库名称、端口号、用户名和密码)</em></p><h2 id="基于CDC变更数据的导入与导出"><a href="#基于CDC变更数据的导入与导出" class="headerlink" title="基于CDC变更数据的导入与导出"></a>基于CDC变更数据的导入与导出</h2><p><em>识别出变化的数据并只导入这部分数据被称为变化捕获数据(CDC)</em></p><h3 id="基于源数据的CDC"><a href="#基于源数据的CDC" class="headerlink" title="基于源数据的CDC"></a>基于源数据的CDC</h3><p><em>基于源数据的CDC：最常见的两个属性(时间戳、自增序列)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缺点</span><br><span class="line">1.只有源数据中包含了插入时间和更新时间两个属性列，才能区分插入时间和更新时间</span><br><span class="line">2.不能捕获物理删除，只能捕获逻辑删除</span><br><span class="line">3.如果同一个时间周期内，数据被更新多次，那么只能同步最后一次更新操作，中间的更新操作都无法导入</span><br><span class="line">4.时间戳和基于序列的CDC操作不适合用于实时场景下数据导入，一般用于批量操作</span><br></pre></td></tr></table></figure><h3 id="基于源数据的CDC案例"><a href="#基于源数据的CDC案例" class="headerlink" title="基于源数据的CDC案例"></a>基于源数据的CDC案例</h3><h3 id="基于自增序列的源数据CDC案例"><a href="#基于自增序列的源数据CDC案例" class="headerlink" title="基于自增序列的源数据CDC案例"></a>基于自增序列的源数据CDC案例</h3><h3 id="基于触发器的CDC"><a href="#基于触发器的CDC" class="headerlink" title="基于触发器的CDC"></a>基于触发器的CDC</h3><h3 id="基于触发器的CDC的案例"><a href="#基于触发器的CDC的案例" class="headerlink" title="基于触发器的CDC的案例"></a>基于触发器的CDC的案例</h3><h3 id="基于快照的CDC"><a href="#基于快照的CDC" class="headerlink" title="基于快照的CDC"></a>基于快照的CDC</h3><h3 id="基于快照的CDC案例"><a href="#基于快照的CDC案例" class="headerlink" title="基于快照的CDC案例"></a>基于快照的CDC案例</h3><h3 id="基于日志的CDC"><a href="#基于日志的CDC" class="headerlink" title="基于日志的CDC"></a>基于日志的CDC</h3><h3 id="基于日志的CDC案例"><a href="#基于日志的CDC案例" class="headerlink" title="基于日志的CDC案例"></a>基于日志的CDC案例</h3><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第二章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-13T03:39:50.000Z</published>
    <updated>2021-01-15T03:07:48.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第二章-kettle的初步使用"><a href="#第二章-kettle的初步使用" class="headerlink" title="第二章-kettle的初步使用"></a>第二章-kettle的初步使用</h1><h2 id="kettle安装"><a href="#kettle安装" class="headerlink" title="kettle安装"></a>kettle安装</h2><h3 id="java安装"><a href="#java安装" class="headerlink" title="java安装"></a>java安装</h3><h3 id="kettle的下载安装与spoon的启动"><a href="#kettle的下载安装与spoon的启动" class="headerlink" title="kettle的下载安装与spoon的启动"></a>kettle的下载安装与spoon的启动</h3><h2 id="kettle的使用"><a href="#kettle的使用" class="headerlink" title="kettle的使用"></a>kettle的使用</h2><h3 id="转换的基本概念"><a href="#转换的基本概念" class="headerlink" title="转换的基本概念"></a>转换的基本概念</h3><p><strong>转换</strong>是ETL解决方案中最主要的部分，它负责处理抽取、转换、加载各阶段对数据行的各种操作</p><p><strong>组成</strong>：步骤、跳、注释</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><strong>步骤</strong>是转换中的基本组成部分，是一个图形化的组件</p><p><em>关键特性：(四点)，最主要的一点是步骤的名字唯一</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 步骤的四个主要特性</span><br><span class="line">1.步骤的名字唯一</span><br><span class="line">2.每个步骤都会读，写数据行（生成步骤是例外，他只能写数据行）</span><br><span class="line">3.步骤之间通过跳进行数据行的单向传输</span><br><span class="line">4.大多数步骤都可以有多个输出跳</span><br><span class="line">5.在运行转换时，一个线程运行一个步骤，所有步骤的线程几乎同时进行</span><br></pre></td></tr></table></figure><h4 id="转换的跳"><a href="#转换的跳" class="headerlink" title="转换的跳"></a>转换的跳</h4><p><em>跳定义了步骤之间进行数据传输的单向通道</em></p><p><strong>从执行角度看</strong>：不可能定义执行的顺序和起点步骤、终点步骤；<br><strong>从功能角度看</strong>：有明确的起点步骤和终点步骤</p><h4 id="数据行"><a href="#数据行" class="headerlink" title="数据行"></a>数据行</h4><p><em>在kettle里数据的单位是<strong>行</strong>.</em></p><p>一个数据行是<strong>零</strong>到<strong>多个字段</strong>的结合，是kettle的数据单位，简称行。</p><p><strong>字段</strong>包括的<strong>数据类型</strong>：<strong>7大类</strong>(String、Number、Integer、Date、Boolean、Binary)</p><h3 id="第一个转换案例"><a href="#第一个转换案例" class="headerlink" title="第一个转换案例"></a>第一个转换案例</h3><h4 id="创建转换"><a href="#创建转换" class="headerlink" title="创建转换"></a>创建转换</h4><h4 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h4><h4 id="可视化编程"><a href="#可视化编程" class="headerlink" title="可视化编程"></a>可视化编程</h4><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><h4 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h4><h4 id="主对象树"><a href="#主对象树" class="headerlink" title="主对象树"></a>主对象树</h4><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><h5 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h5><p><strong>环境变量</strong>：全局的，对所有转换和作业有效</p><h5 id="命名参数配置"><a href="#命名参数配置" class="headerlink" title="命名参数配置"></a>命名参数配置</h5><p><strong>命名参数</strong>：局部的，仅对当前转换和作业有效</p><h5 id="定时启动转换"><a href="#定时启动转换" class="headerlink" title="定时启动转换"></a>定时启动转换</h5><p><em>在windows下，可以使用控制面板中的计划任务执行批处理</em></p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;d d:\data-integration</span><br><span class="line">pan &#x2F;file&#x3D;xxxxx.ktr &#x2F;level&#x3D;Dtailed &#x2F;logfile&#x3D;xxx.log0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;参数描述表</span><br><span class="line">参数名     参数值             作用</span><br><span class="line">file文件名指定转换或作业的文件名</span><br><span class="line">levelError, Nothing,  指定日志级别</span><br><span class="line">Detail,Debug,Rowlevel</span><br><span class="line">logfile日志文件名指定转换或作业的日志文件名</span><br></pre></td></tr></table></figure><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章-大数据预处理技术</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF.html</id>
    <published>2021-01-13T02:55:50.000Z</published>
    <updated>2021-01-15T02:55:13.156Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第一章-数据预处理概述"><a href="#第一章-数据预处理概述" class="headerlink" title="第一章-数据预处理概述"></a>第一章-数据预处理概述</h1><h2 id="数据与处理的背景与目的"><a href="#数据与处理的背景与目的" class="headerlink" title="数据与处理的背景与目的"></a>数据与处理的背景与目的</h2><h3 id="数据预处理背景：数据质量"><a href="#数据预处理背景：数据质量" class="headerlink" title="数据预处理背景：数据质量"></a>数据预处理背景：数据质量</h3><p><em>高质量数据：能满足应用要求</em></p><p><em>数据质量涉及的因素：<strong>准确性，完整性，一致性，时效性，相关性，可信性，可解释性</strong>.</em></p><h4 id="数据库和数据仓库的角度"><a href="#数据库和数据仓库的角度" class="headerlink" title="数据库和数据仓库的角度"></a>数据库和数据仓库的角度</h4><p><em>当今世界大型数据库和数据仓库的共同缺点是存在<strong>不正确</strong>，<strong>不完整</strong>，<strong>不一致</strong>.</em></p><h4 id="应用角度"><a href="#应用角度" class="headerlink" title="应用角度"></a>应用角度</h4><p><em>时效性，相关性</em></p><h4 id="用户角度"><a href="#用户角度" class="headerlink" title="用户角度"></a>用户角度</h4><p><em>可信性，可解释性</em></p><h3 id="数据预处理目的"><a href="#数据预处理目的" class="headerlink" title="数据预处理目的"></a>数据预处理目的</h3><p><em>在数据挖掘之前，必须对收集的原始数据进行预处理，达到改善数据的质量，提高数据挖掘过程的准确率和效率的目的</em></p><h2 id="数据预处理流程"><a href="#数据预处理流程" class="headerlink" title="数据预处理流程"></a>数据预处理流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始数据采集&#x3D;&gt;数据清理&#x3D;&gt;数据集成&#x3D;》数据转换&#x3D;&gt;数据规约</span><br></pre></td></tr></table></figure><p><em>这里的流程顺序不用必须严格按照1/2/3/4顺序进行</em></p><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p><strong>脏数据</strong>：由于重复录入，并发处理等不规范的操作，导致产生不完整，不准确的，无效的数据。<br><strong>脏数据</strong>划分为<strong>缺省值</strong>和<strong>噪声</strong>(噪声是被测量变量的随机误差或方差）</p><p><em>数据清理：填充缺失值、光滑噪声和识别离群点</em></p><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><h4 id="噪声数据"><a href="#噪声数据" class="headerlink" title="噪声数据"></a>噪声数据</h4><h4 id="不一致数据"><a href="#不一致数据" class="headerlink" title="不一致数据"></a>不一致数据</h4><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p><em>合并来自多个数据源的数据</em></p><h4 id="实体识别问题"><a href="#实体识别问题" class="headerlink" title="实体识别问题"></a>实体识别问题</h4><h4 id="冗余和相关分析"><a href="#冗余和相关分析" class="headerlink" title="冗余和相关分析"></a>冗余和相关分析</h4><h4 id="元组重复"><a href="#元组重复" class="headerlink" title="元组重复"></a>元组重复</h4><h4 id="数据值冲突的检测与处理"><a href="#数据值冲突的检测与处理" class="headerlink" title="数据值冲突的检测与处理"></a>数据值冲突的检测与处理</h4><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><p><em>在数据预处理阶段，<strong>数据被变换或统一</strong>，使挖掘过程可能更有效，挖掘的模式可能更容易理解</em></p><h4 id="数据变换策略"><a href="#数据变换策略" class="headerlink" title="数据变换策略"></a>数据变换策略</h4><h4 id="通过规范化变换数据"><a href="#通过规范化变换数据" class="headerlink" title="通过规范化变换数据"></a>通过规范化变换数据</h4><h4 id="通过分箱离散化"><a href="#通过分箱离散化" class="headerlink" title="通过分箱离散化"></a>通过分箱离散化</h4><h4 id="通过直方图分析离散化"><a href="#通过直方图分析离散化" class="headerlink" title="通过直方图分析离散化"></a>通过直方图分析离散化</h4><h4 id="通过聚类，决策树和相关分析离散化"><a href="#通过聚类，决策树和相关分析离散化" class="headerlink" title="通过聚类，决策树和相关分析离散化"></a>通过聚类，决策树和相关分析离散化</h4><h4 id="标称数据的概念分层产生"><a href="#标称数据的概念分层产生" class="headerlink" title="标称数据的概念分层产生"></a>标称数据的概念分层产生</h4><h3 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h3><p><em>尽可能保持数据原貌的前提下，最大限度地精简数据量</em></p><p><strong>数据规约的策略</strong>：维规约、数量规约、数据压缩</p><h2 id="数据预处理的工具"><a href="#数据预处理的工具" class="headerlink" title="数据预处理的工具"></a>数据预处理的工具</h2><p><strong>工具类手段</strong>：Kettle<br><strong>编程类手段</strong>：Python语言</p><hr><blockquote><p>死并非生的对立面，是生的一部分永存。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>第五章-MongoDB基础</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%BA%94%E7%AB%A0-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8E%E5%BA%94%E7%94%A8.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%BA%94%E7%AB%A0-NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8E%E5%BA%94%E7%94%A8.html</id>
    <published>2021-01-05T05:21:20.000Z</published>
    <updated>2021-01-06T05:23:57.460Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第五章-MongoDB基础"><a href="#第五章-MongoDB基础" class="headerlink" title="第五章-MongoDB基础"></a>第五章-MongoDB基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em>开源数据库，是目前NoSQL数据库中使用最广泛的数据库之一</em></p><p><em>是一个开源文档数据库，是用C++语言编写的非关系型数据库</em></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文档数据模型"><a href="#文档数据模型" class="headerlink" title="文档数据模型"></a>文档数据模型</h3><p><em>传统的关系型数据库需要对表结构进行预先定义和严格的要求，而这样的严格要求，导致了处理数据的过程更加繁琐，甚至降低了执行效率。在数据量达到一定规模的情况下，传统关系型数据库反应迟钝。</em></p><p><em>文档存储支持对结构化数据的访问，与关系模型不同的是，文档存储没有强制的架构。文档存储以封包键值对的方式进行存储，文档存储模型支持嵌套结构</em></p><p><em>文档数据库无需事先定义数据存储结构</em>、</p><h3 id="文档存储结构"><a href="#文档存储结构" class="headerlink" title="文档存储结构"></a>文档存储结构</h3><p><em>文档存储结构可分为四个层次：键值对，文档，集合，数据库</em></p><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><p><em>文档型数据库存储结构的基本单位，具体包含了数据和类型</em></p><p><em>键为字符串类型，值为五种基本类型，数组，日期，嵌套</em></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><em>文档是MongoDB的核心概念，是数据的基本单元</em></p><p><em>是一组有序的键值对集合</em></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><em>MongoDB将文档存储在集合中，一个集合是一些文档构成的集合</em></p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p><em>在MongoDB中，数据库有集合组成</em></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><em>MongoDB所采用的数据格式称为BSON，是一种基于JSON的二进制序列化格式</em></p><p><em>MongoDB改进的主要特性有下面三点：</em></p><p><em>(1) 更快的遍历速度</em></p><p><em>(2) 操作更加简单</em></p><p><em>(3) 支持更多的数据类型</em></p><h3 id="MongoDB的安装与测试"><a href="#MongoDB的安装与测试" class="headerlink" title="MongoDB的安装与测试"></a>MongoDB的安装与测试</h3><h2 id="数据库与集合的基本操作"><a href="#数据库与集合的基本操作" class="headerlink" title="数据库与集合的基本操作"></a>数据库与集合的基本操作</h2><h3 id="数据库命名规则"><a href="#数据库命名规则" class="headerlink" title="数据库命名规则"></a>数据库命名规则</h3><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="创建自定义数据库"><a href="#创建自定义数据库" class="headerlink" title="创建自定义数据库"></a>创建自定义数据库</h4><p><em>没有则创建该数据库</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use myDB</span><br></pre></td></tr></table></figure><h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure><h4 id="统计数据库信息"><a href="#统计数据库信息" class="headerlink" title="统计数据库信息"></a>统计数据库信息</h4><p><em>操作之前，要先切到该数据库</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br><span class="line">db.stats()</span><br></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h4 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h4><p><em>查看当前数据库下的所有集合</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.getCollectionNames()</span><br></pre></td></tr></table></figure><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><h4 id="集合名称的命名规则"><a href="#集合名称的命名规则" class="headerlink" title="集合名称的命名规则"></a>集合名称的命名规则</h4><h4 id="集合操作-1"><a href="#集合操作-1" class="headerlink" title="集合操作"></a>集合操作</h4><p><em>有显示和隐式创建集合两种方法</em></p><h5 id="集合参数"><a href="#集合参数" class="headerlink" title="集合参数"></a>集合参数</h5><p><em>capped</em>:<em>上限集合，是否限制大小</em></p><p><em>max<em>：</em>最大文档数，可选</em></p><p><em>size<em>：</em>具体集合大小，如果capped为True，则它必须命名</em></p><h5 id="显示创建"><a href="#显示创建" class="headerlink" title="显示创建"></a>显示创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use myDatabase</span><br><span class="line">db.createCollection(&quot;mycl&quot;,&#123;capped:true, size:6142800, max:10000&#125;)</span><br></pre></td></tr></table></figure><h5 id="隐式创建"><a href="#隐式创建" class="headerlink" title="隐式创建"></a>隐式创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycl.insert(&#123;&quot;name&quot;:&quot;tom&quot;&#125;)</span><br></pre></td></tr></table></figure><h4 id="集合的其它操作"><a href="#集合的其它操作" class="headerlink" title="集合的其它操作"></a>集合的其它操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文档的基本操作"><a href="#文档的基本操作" class="headerlink" title="文档的基本操作"></a>文档的基本操作</h2><h3 id="文档的键定义规则"><a href="#文档的键定义规则" class="headerlink" title="文档的键定义规则"></a>文档的键定义规则</h3><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NoSQL数据库原理与与应用" scheme="http://tianyong.fun/categories/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>第一章-NoSQL数据库原理与应用</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0NoSQL%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8E%E5%BA%94%E7%94%A8.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%95%B0NoSQL%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E4%B8%8E%E5%BA%94%E7%94%A8.html</id>
    <published>2021-01-04T05:28:04.000Z</published>
    <updated>2021-01-05T05:21:30.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第一章-NoSQL数据库原理与应用"><a href="#第一章-NoSQL数据库原理与应用" class="headerlink" title="第一章-NoSQL数据库原理与应用"></a>第一章-NoSQL数据库原理与应用</h1><h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p><em>由数据库，数据库管理系统，应用程序，用户组成</em></p><h3 id="数据库系统的基本概念"><a href="#数据库系统的基本概念" class="headerlink" title="数据库系统的基本概念"></a>数据库系统的基本概念</h3><h4 id="数据库DBS"><a href="#数据库DBS" class="headerlink" title="数据库DBS"></a>数据库DBS</h4><p><em>是长期存储在计算机内，<strong>有组织</strong>，<strong>统一管理的</strong>，可以<strong>表现为多种形式的</strong>，<strong>可共享</strong>的数据集合</em></p><p><em>数据库根据不同的逻辑模型可以分为三种：层次型，网状型，关系型</em></p><p><em>层次型：简单，冗余度过高</em></p><p><em>网状型：随着应用范围的扩展，数据库的结构变得越来越复杂</em></p><p><em>关系型：二维表格来表示实体集合以及数据间的联系的一种模型</em></p><h4 id="数据库管理系统DBMS"><a href="#数据库管理系统DBMS" class="headerlink" title="数据库管理系统DBMS"></a>数据库管理系统DBMS</h4><p><em>是一种操作和管理数据库的大型软件，用于建立，使用和维护数据库</em></p><h5 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h5><p><em>DBMS提供数据定义语言DDL，供用户定义，创建和修改数据库的结构</em></p><h5 id="数据操纵"><a href="#数据操纵" class="headerlink" title="数据操纵"></a>数据操纵</h5><p><em>DBMS提供数据操纵语言DML，实现用户对数据的操纵功能，包括对数据库数据的插入，删除，更新等操作</em></p><h5 id="数据库的运行管理"><a href="#数据库的运行管理" class="headerlink" title="数据库的运行管理"></a>数据库的运行管理</h5><h5 id="数据组织，存储与管理"><a href="#数据组织，存储与管理" class="headerlink" title="数据组织，存储与管理"></a>数据组织，存储与管理</h5><h5 id="数据库的维护"><a href="#数据库的维护" class="headerlink" title="数据库的维护"></a>数据库的维护</h5><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><h4 id="关系型数据库的基本概念"><a href="#关系型数据库的基本概念" class="headerlink" title="关系型数据库的基本概念"></a>关系型数据库的基本概念</h4><p><em>在关系型数据库中，实体以及实体间的联系均由单一的结构类型表示，这种逻辑结构是一张二维表</em></p><h4 id="结构化查询语言"><a href="#结构化查询语言" class="headerlink" title="结构化查询语言"></a>结构化查询语言</h4><p><em>关系型数据库的核心是其结构化查询语言SQL，SQL涵盖数据的定义，操纵，查询，控制，是一个综合的，通用的且简单易懂的数据库管理语言</em></p><h5 id="数据定义语言DDL"><a href="#数据定义语言DDL" class="headerlink" title="数据定义语言DDL"></a>数据定义语言DDL</h5><p><em>CREATE，DROP，ALTER</em></p><h5 id="数据查询语言DQL"><a href="#数据查询语言DQL" class="headerlink" title="数据查询语言DQL"></a>数据查询语言DQL</h5><p><em>SELECT</em></p><h5 id="数据操纵语言"><a href="#数据操纵语言" class="headerlink" title="数据操纵语言"></a>数据操纵语言</h5><p><em>INSERT，DELETE，UPDATE</em></p><h5 id="数据控制语言DCL"><a href="#数据控制语言DCL" class="headerlink" title="数据控制语言DCL"></a>数据控制语言DCL</h5><p><em>是对数据访问权进行控制的指令</em></p><h4 id="关系型数据库的优缺点"><a href="#关系型数据库的优缺点" class="headerlink" title="关系型数据库的优缺点"></a>关系型数据库的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><em>易于理解，使用方便，易于维护</em></p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><em>高并发读写能力差，对海量数据的读写效率低，扩展性差</em></p><h3 id="NoSQL数据库的特点"><a href="#NoSQL数据库的特点" class="headerlink" title="NoSQL数据库的特点"></a>NoSQL数据库的特点</h3><p><em>最初为满足互联网时代的业务需求而产生。互联网时代具有大量化，多样化，快速化等特点。数据不仅仅是传统的结构化数据，还包含大量非结构化和半结构化数据，关系型数据库无法存储此类数据</em></p><h4 id="灵活的数据模型"><a href="#灵活的数据模型" class="headerlink" title="灵活的数据模型"></a>灵活的数据模型</h4><h4 id="可伸缩性强"><a href="#可伸缩性强" class="headerlink" title="可伸缩性强"></a>可伸缩性强</h4><p><em>关系型数据库：中心化，是纵向扩展而不是横向扩展的。这使得它们不适合那些需要简单且动态可伸缩性的应用</em></p><p><em>NoSQL数据库从一开始就是分布式，横向扩展的，因此非常适合互联网应用分布式的特性</em></p><h4 id="自动分片"><a href="#自动分片" class="headerlink" title="自动分片"></a>自动分片</h4><h4 id="自动复制"><a href="#自动复制" class="headerlink" title="自动复制"></a>自动复制</h4><h2 id="分布式数据库的数据管理"><a href="#分布式数据库的数据管理" class="headerlink" title="分布式数据库的数据管理"></a>分布式数据库的数据管理</h2><h3 id="分布式数据处理"><a href="#分布式数据处理" class="headerlink" title="分布式数据处理"></a>分布式数据处理</h3><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p><em>CAP理论是指在一个分布式系统中，一致性C，可用性A，分区容错性P，三者不可兼得</em></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="一致性C"><a href="#一致性C" class="headerlink" title="一致性C"></a>一致性C</h5><p><em>是指更新操作成功后，所有节点在同一时间的数据完全一致</em></p><p><em>一致性在并发读写时才会出现的问题</em></p><h5 id="可用性A"><a href="#可用性A" class="headerlink" title="可用性A"></a>可用性A</h5><p><em>即用户访问数据时，系统能否在正常响应时间返回结果</em></p><p><em>在通常情况下，可用性与分布式数据冗余，负载均衡等有很大的关联</em></p><h5 id="分区容错性P"><a href="#分区容错性P" class="headerlink" title="分区容错性P"></a>分区容错性P</h5><p><em>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务</em></p><h4 id="相互关联"><a href="#相互关联" class="headerlink" title="相互关联"></a>相互关联</h4><h5 id="CA-without-P"><a href="#CA-without-P" class="headerlink" title="CA without P"></a>CA without P</h5><h5 id="CP-without-A"><a href="#CP-without-A" class="headerlink" title="CP without A"></a>CP without A</h5><h5 id="PA-without-C"><a href="#PA-without-C" class="headerlink" title="PA without C"></a>PA without C</h5><h3 id="ACID与BASE"><a href="#ACID与BASE" class="headerlink" title="ACID与BASE"></a>ACID与BASE</h3><h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h4><h4 id="BASE原理"><a href="#BASE原理" class="headerlink" title="BASE原理"></a>BASE原理</h4><h3 id="NoSQL数据库分类"><a href="#NoSQL数据库分类" class="headerlink" title="NoSQL数据库分类"></a>NoSQL数据库分类</h3><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="NoSQL数据库原理与应用" scheme="http://tianyong.fun/categories/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>第八章-基于python的数据整理</title>
    <link href="http://tianyong.fun/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html"/>
    <id>http://tianyong.fun/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%9F%BA%E4%BA%8Epython%E7%9A%84%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86.html</id>
    <published>2021-01-02T11:34:58.000Z</published>
    <updated>2021-01-04T03:02:06.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><script type="text/javascript" src="/js/src/bai.js"></script><h1 id="第八章-基于python的数据整理"><a href="#第八章-基于python的数据整理" class="headerlink" title="第八章-基于python的数据整理"></a>第八章-基于python的数据整理</h1><h2 id="合并多个数据集"><a href="#合并多个数据集" class="headerlink" title="合并多个数据集"></a>合并多个数据集</h2><p><em>pandas提供以下几种方法合并多个数据集：</em></p><p><strong>pandas.merge</strong>:<em>基于一个键或多个键连接多个DataFrame的行</em></p><p><strong>pandas.concat</strong>:<em>按行或按列将不同的对象叠加到一起</em></p><p><strong>combine_first</strong>:<em>使用一个对象中的数据填充另一个对象中对应位置的缺失值</em></p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><em>默认连接为类似sql的inner join操作</em></p><p><em>利用how参数，实现其它连接方式，left join, right join, outer join</em></p><h4 id="不指明使用某一列作为连接键"><a href="#不指明使用某一列作为连接键" class="headerlink" title="不指明使用某一列作为连接键"></a>不指明使用某一列作为连接键</h4><p><em>在这种情况下使用重叠列作为键进行连接</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df1 = DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data2'</span>:range(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>], <span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line">pd.merge(df1, df2)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/s9SNY6" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/s9SNY6.png" alt="s9SNY6.png" border="0"></a></p><h4 id="指明连接键"><a href="#指明连接键" class="headerlink" title="指明连接键"></a>指明连接键</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 等同于上例</span><br><span class="line">pd.merge(df1,df2, on=<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure><h4 id="使用不同名的键连接"><a href="#使用不同名的键连接" class="headerlink" title="使用不同名的键连接"></a>使用不同名的键连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df3 = DataFrame(&#123;<span class="string">'lkey'</span>:[<span class="string">'b'</span>,<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>,<span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>:range(<span class="number">7</span>)&#125;)</span><br><span class="line">df4 = DaraFrame(&#123;<span class="string">'rkey'</span>:[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>], <span class="string">'data2'</span>:range(<span class="number">3</span>)&#125;)</span><br><span class="line">pd.merge(df1,df2, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/s9pOUI" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/s9pOUI.png" alt="s9pOUI.png" border="0"></a></p><h4 id="how参数"><a href="#how参数" class="headerlink" title="how参数"></a>how参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/s99YRK" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/s99YRK.png" alt="s99YRK.png" border="0"></a></p><h4 id="使用多个键连接"><a href="#使用多个键连接" class="headerlink" title="使用多个键连接"></a>使用多个键连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">left = DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">                 <span class="string">'key2'</span>:[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">                 <span class="string">'lval'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span><br><span class="line">right = DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>,<span class="string">'bar'</span>],</span><br><span class="line">                  <span class="string">'key2'</span>:[<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">                  <span class="string">'rval'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]&#125;)</span><br><span class="line">pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/s9FQl6" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/s9FQl6.png" alt="s9FQl6.png" border="0"></a></p><h3 id="使用index进行DataFrame合并"><a href="#使用index进行DataFrame合并" class="headerlink" title="使用index进行DataFrame合并"></a>使用index进行DataFrame合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left1=DataFrame(&#123;<span class="string">'key'</span>:[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">                <span class="string">'value'</span>:range(<span class="number">6</span>)&#125;)</span><br><span class="line">right1=DataFrame(&#123;<span class="string">'group_val'</span>:[<span class="number">3.5</span>, <span class="number">7</span>]&#125;,</span><br><span class="line">                 index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>, how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCQuGT" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/sCQuGT.png" alt="sCQuGT.png" border="0"></a></p><h3 id="沿着横轴或纵轴串接"><a href="#沿着横轴或纵轴串接" class="headerlink" title="沿着横轴或纵轴串接"></a>沿着横轴或纵轴串接</h3><h4 id="numpy的concatenate函数"><a href="#numpy的concatenate函数" class="headerlink" title="numpy的concatenate函数"></a>numpy的concatenate函数</h4><p><em>NumPy库的concatenate函数用于串接起NumPy的原生数组</em></p><p><em>axis参数默认为0，沿着竖轴连接</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCQ7oq" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/sCQ7oq.png" alt="sCQ7oq.png" border="0"></a></p><h4 id="pandas的concat函数"><a href="#pandas的concat函数" class="headerlink" title="pandas的concat函数"></a>pandas的concat函数</h4><h5 id="用于Series数据类型"><a href="#用于Series数据类型" class="headerlink" title="用于Series数据类型"></a>用于Series数据类型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s1 = Series([<span class="number">0</span>,<span class="number">1</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">s2 = Series([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">pd.concat([s1, s2])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">a <span class="number">0</span></span><br><span class="line">    b <span class="number">1</span></span><br><span class="line">    c <span class="number">2</span></span><br><span class="line">    d <span class="number">3</span></span><br><span class="line">    e <span class="number">4</span></span><br><span class="line">pd.concat([s1, s2], axis=<span class="number">1</span>) // 此时得到DataFrame对象，连接方式为outer join</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sC1JC6" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/sC1JC6.png" alt="sC1JC6.png" border="0"></a></p><p><em>可以通过join参数修改连接方式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = Series([<span class="number">0</span>,<span class="number">1</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">s3= Series([<span class="number">5</span>,<span class="number">6</span>], index=[<span class="string">'f'</span>,<span class="string">'g'</span>])</span><br><span class="line">s4 = pd.concat([s1*<span class="number">5</span>,s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sC8qHJ" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/03/sC8qHJ.png" alt="sC8qHJ.png" border="0"></a></p><h5 id="用于DataFrame数据类型"><a href="#用于DataFrame数据类型" class="headerlink" title="用于DataFrame数据类型"></a>用于DataFrame数据类型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = DataFrame(np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>),index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line">df2 = DataFrame(<span class="number">5</span>+np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>), index=[<span class="string">'a'</span>,<span class="string">'c'</span>], columns=[<span class="string">'three'</span>,<span class="string">'four'</span>])</span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCbLlj" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/04/sCbLlj.png" alt="sCbLlj.png" border="0"></a></p><h2 id="数据重塑"><a href="#数据重塑" class="headerlink" title="数据重塑"></a>数据重塑</h2><p><em>数据重塑：是指转换输入的数据结构，使其适合后续的分析</em></p><p><em>pandas提供了数据重塑的基本操作，这些操作被用于二维度表格数据</em></p><h3 id="多级索引数据的重塑"><a href="#多级索引数据的重塑" class="headerlink" title="多级索引数据的重塑"></a>多级索引数据的重塑</h3><p><em>DataFrame可以设置多级索引。对于多级索引的数据，pandas的stack方法将数据集的列旋转为行</em></p><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data=DataFrame(np.arange(<span class="number">6.</span>reshape((<span class="number">2</span>,<span class="number">3</span>)),index=pd.Index([<span class="string">'ohio'</span>,<span class="string">'colorado'</span>], name=<span class="string">'state'</span>), columns=pd.Index([<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>], name=<span class="string">'number'</span>))</span><br><span class="line">&gt;&gt;&gt;data.stack()</span><br></pre></td></tr></table></figure><h4 id="unstack"><a href="#unstack" class="headerlink" title="unstack"></a>unstack</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = data.stack()</span><br><span class="line">result = data.unstack()</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCXL5V" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/04/sCXL5V.png" alt="sCXL5V.png" border="0"></a></p><p><em>默认情况下转换内层级别索引，通过传递一个级别的标号或级别的别称，可以指定要转换的级别，以下两种操作方式：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.unstack(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.unstack(<span class="string">'state'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCxoKe" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/04/sCxoKe.png" alt="sCxoKe.png" border="0"></a></p><h3 id="应用pivot方法重塑数据"><a href="#应用pivot方法重塑数据" class="headerlink" title="应用pivot方法重塑数据"></a>应用pivot方法重塑数据</h3><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h3><p><em>这两个方法默认以整行判断，也可以指定进行部分列判断重复</em></p><h4 id="duplicated"><a href="#duplicated" class="headerlink" title="duplicated()"></a>duplicated()</h4><p><em>判断是否重复，返回一个bool型series</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = DataFrame(&#123;<span class="string">'k1'</span>:[<span class="string">'zhongxing'</span>,<span class="string">'Huawei'</span>]*<span class="number">3</span>+[<span class="string">'Huawei'</span>], <span class="string">'k2'</span>:[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]&#125;)</span><br><span class="line">data.duplicated()</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sCzXw9" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/04/sCzXw9.png" alt="sCzXw9.png" border="0"></a></p><h4 id="drop-duplicates"><a href="#drop-duplicates" class="headerlink" title="drop_duplicates()"></a>drop_duplicates()</h4><p><em>删除重复行</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.drop_duplicates()</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/sPSCQO" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://s3.ax1x.com/2021/01/04/sPSCQO.png" alt="sPSCQO.png" border="0"></a></p><h3 id="利用函数或隐射进行数据转换"><a href="#利用函数或隐射进行数据转换" class="headerlink" title="利用函数或隐射进行数据转换"></a>利用函数或隐射进行数据转换</h3><h3 id="值转换"><a href="#值转换" class="headerlink" title="值转换"></a>值转换</h3><h3 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h3><h3 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h3><h3 id="检测或过滤异常值"><a href="#检测或过滤异常值" class="headerlink" title="检测或过滤异常值"></a>检测或过滤异常值</h3><h3 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h3><h3 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h3><hr><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="大数据预处理技术" scheme="http://tianyong.fun/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
